// !!! THIS FILE IS AUTO-GENERATED BY ZigAdapter.php, DO NOT EDIT !!!
// Generated from: structs.json

const std = @import("std");

pub const Events = enum(u32) {
    spriteAdd = 0,
    spriteRemove = 1,
    spriteMove = 2,
    spriteScale = 3,
    spriteResize = 4,
    spriteRotate = 5,
    spriteColor = 6,
    spriteSpeed = 7,
    spriteTextureLoad = 8,
    spriteTextureSet = 9,
    spriteSetSourceRect = 10,
    geomAddPoint = 50,
    geomAddLine = 51,
    geomAddRect = 52,
    geomAddFillRect = 53,
    geomAddPacked = 54,
    geomRemove = 55,
    geomSetColor = 56,

    inputKeyup = 100,
    inputKeydown = 101,
    inputMouseup = 102,
    inputMousedown = 103,
    inputMousemotion = 104,

    windowTitle = 200,
    windowResize = 201,
    windowFlags = 202,

    textAdd = 300,
    textSetString = 301,

    audioLoad = 400,
    audioLoaded = 401,
    audioPlay = 402,
    audioStopAll = 403,
    audioSetMasterVolume = 404,
    audioPause = 405,
    audioStop = 406,
    audioUnload = 407,
    audioSetVolume = 408,

    physicsAddBody = 500,
    physicsRemoveBody = 501,
    physicsApplyForce = 502,
    physicsApplyImpulse = 503,
    physicsSetVelocity = 504,
    physicsSetPosition = 505,
    physicsSetRotation = 506,
    physicsCollisionBegin = 550,
    physicsCollisionSeparate = 551,
    physicsSyncTransform = 552,
    physicsSetDebugMode = 553,

    plugin = 1000,
    pluginLoad = 1001,
    pluginUnload = 1002,
    pluginSet = 1003,
    pluginEventStacking = 1004,
    pluginSubscribeEvent = 1005,
    pluginUnsubscribeEvent = 1006,

    cameraSetPosition = 2000,
    cameraMove = 2001,
    cameraSetZoom = 2002,
    cameraSetRotation = 2003,
    cameraFollowEntity = 2004,
    cameraStopFollowing = 2005,

    scriptSubscribe = 3000,
    scriptUnsubscribe = 3001,

    uiBeginWindow = 4000,
    uiEndWindow = 4001,
    uiText = 4002,
    uiButton = 4003,
    uiSetNextWindowPos = 4004,
    uiSetNextWindowSize = 4005,
    uiElementClicked = 4500,
    uiWindowClosed = 4501,
};

pub const PackedAudioLoadEvent = extern struct {
    pathLength: u32, // Length of the audio file path that follows.
};

pub const PackedAudioLoadedEvent = extern struct {
    audioId: u64, // The ID assigned to the loaded audio.
};

pub const PackedAudioPauseEvent = extern struct {
    audioId: u64, // The ID of the audio to pause.
};

pub const PackedAudioPlayEvent = extern struct {
    audioId: u64, // The ID of the audio to play.
};

pub const PackedAudioSetMasterVolumeEvent = extern struct {
    volume: f32, // Volume level (e.g., 0.0 to 1.0).
};

pub const PackedAudioSetVolumeEvent = extern struct {
    audioId: u64, // The ID of the audio to modify.
    volume: f32, // Volume level (0.0 to 1.0).
    _padding: u32, // Padding for alignment.
};

pub const PackedAudioStopAllEvent = extern struct {
    _unused: u8, // Padding to ensure non-zero struct size (MSVC compatibility).
};

pub const PackedAudioStopEvent = extern struct {
    audioId: u64, // The ID of the audio to stop.
};

pub const PackedAudioUnloadEvent = extern struct {
    audioId: u64, // The ID of the audio to unload.
};

pub const PackedCameraFollowEntityEvent = extern struct {
    id1: i64, // Primary ID of the entity to follow.
    id2: i64, // Secondary ID of the entity to follow.
};

pub const PackedCameraMoveEvent = extern struct {
    deltaX: f64, // Amount to move the camera on the X axis.
    deltaY: f64, // Amount to move the camera on the Y axis.
};

pub const PackedCameraSetPositionEvent = extern struct {
    positionX: f64, // New X position for the camera's top-left corner.
    positionY: f64, // New Y position for the camera's top-left corner.
};

pub const PackedCameraSetRotationEvent = extern struct {
    angleInRadians: f64, // New camera rotation in radians.
};

pub const PackedCameraSetZoomEvent = extern struct {
    zoom: f64, // New zoom level. 1.0 is default, 2.0 is zoomed in.
};

pub const PackedCameraStopFollowingEvent = extern struct {
    _unused: u8, // Padding to ensure non-zero struct size (MSVC compatibility).
};

pub const PackedGeomAddLineEvent = extern struct {
    id1: i64, // Primary identifier.
    id2: i64, // Secondary identifier.
    z: f64, // Z position (depth).
    r: u8, // Red color component (0-255).
    g: u8, // Green color component (0-255).
    b: u8, // Blue color component (0-255).
    a: u8, // Alpha color component (0-255).
    isScreenSpace: u8, // If the geometry is unaffected by the camera.
    _padding: [3]u8, // Padding for alignment.
    x1: f32, // Start X coordinate.
    y1: f32, // Start Y coordinate.
    x2: f32, // End X coordinate.
    y2: f32, // End Y coordinate.
};

pub const PackedGeomAddPackedHeaderEvent = extern struct {
    id1: i64, // Primary identifier.
    id2: i64, // Secondary identifier.
    z: f64, // Z position (depth).
    r: u8, // Red color component (0-255).
    g: u8, // Green color component (0-255).
    b: u8, // Blue color component (0-255).
    a: u8, // Alpha color component (0-255).
    isScreenSpace: u8, // If the geometry is unaffected by the camera.
    _padding: u16, // Padding for alignment.
    primitiveType: u32, // Raw value from PrimitiveType enum (point, line, rect).
    count: u32, // Number of primitives that follow this header.
};

pub const PackedGeomAddPointEvent = extern struct {
    id1: i64, // Primary identifier.
    id2: i64, // Secondary identifier.
    z: f64, // Z position (depth).
    r: u8, // Red color component (0-255).
    g: u8, // Green color component (0-255).
    b: u8, // Blue color component (0-255).
    a: u8, // Alpha color component (0-255).
    isScreenSpace: u8, // If the geometry is unaffected by the camera.
    _padding: [3]u8, // Padding for alignment.
    x: f32, // X coordinate.
    y: f32, // Y coordinate.
};

pub const PackedGeomAddRectEvent = extern struct {
    id1: i64, // Primary identifier.
    id2: i64, // Secondary identifier.
    z: f64, // Z position (depth).
    r: u8, // Red color component (0-255).
    g: u8, // Green color component (0-255).
    b: u8, // Blue color component (0-255).
    a: u8, // Alpha color component (0-255).
    isScreenSpace: u8, // If the geometry is unaffected by the camera.
    _padding: [3]u8, // Padding for alignment.
    x: f32, // Top-left X coordinate.
    y: f32, // Top-left Y coordinate.
    w: f32, // Width.
    h: f32, // Height.
};

pub const PackedGeomRemoveEvent = extern struct {
    id1: i64, // Primary ID of geometry to remove.
    id2: i64, // Secondary ID of geometry to remove.
};

pub const PackedGeomSetColorEvent = extern struct {
    id1: i64, // Primary ID of the geometry entity.
    id2: i64, // Secondary ID of the geometry entity.
    r: u8, // New red component (0-255).
    g: u8, // New green component (0-255).
    b: u8, // New blue component (0-255).
    a: u8, // New alpha component (0-255).
    _padding: u32, // Padding for alignment.
};

pub const PackedKeyEvent = extern struct {
    scancode: i32, // Physical key scancode.
    keycode: u32, // Keycode (e.g., Keycode.A).
    mod: u16, // Key modifiers (Shift, Ctrl, etc.).
    isRepeat: u8, // 1 if this is a key repeat, 0 otherwise.
    _padding: u8, // Padding for alignment.
};

pub const PackedMouseButtonEvent = extern struct {
    x: f32, // X coordinate of the mouse.
    y: f32, // Y coordinate of the mouse.
    button: u8, // Mouse button index.
    clicks: u8, // Number of clicks (1 for single, 2 for double).
    _padding: u16, // Padding for alignment.
};

pub const PackedMouseMotionEvent = extern struct {
    x: f32, // Absolute X coordinate.
    y: f32, // Absolute Y coordinate.
    xrel: f32, // Relative X motion.
    yrel: f32, // Relative Y motion.
};

pub const PackedPhysicsAddBodyEvent = extern struct {
    id1: i64, // Primary identifier.
    id2: i64, // Secondary identifier.
    positionX: f64, // Initial X position.
    positionY: f64, // Initial Y position.
    bodyType: u8, // Body type (static, kinematic, dynamic).
    shapeType: u8, // Shape type (box, circle).
    lockRotation: u8, // Rotation lock (0 = unlocked, 1 = locked). Prevent bodies from falling over.
    _padding: [5]u8, // Padding for 8-byte alignment.
    mass: f64, // Mass of the body.
    friction: f64, // Friction coefficient.
    elasticity: f64, // Elasticity (bounciness).
    width: f64, // Width of the shape (or radius).
    height: f64, // Height of the shape (unused if circle).
};

pub const PackedPhysicsApplyForceEvent = extern struct {
    id1: i64, // Primary ID of the body.
    id2: i64, // Secondary ID of the body.
    forceX: f64, // Force vector X component.
    forceY: f64, // Force vector Y component.
};

pub const PackedPhysicsApplyImpulseEvent = extern struct {
    id1: i64, // Primary ID of the body.
    id2: i64, // Secondary ID of the body.
    impulseX: f64, // Impulse vector X component.
    impulseY: f64, // Impulse vector Y component.
};

pub const PackedPhysicsCollisionEvent = extern struct {
    id1_A: i64, // Primary ID of the first body.
    id2_A: i64, // Secondary ID of the first body.
    id1_B: i64, // Primary ID of the second body.
    id2_B: i64, // Secondary ID of the second body.
};

pub const PackedPhysicsRemoveBodyEvent = extern struct {
    id1: i64, // Primary ID of body to remove.
    id2: i64, // Secondary ID of body to remove.
};

pub const PackedPhysicsSetDebugModeEvent = extern struct {
    enabled: u8, // 1 to enable debug drawing, 0 to disable.
    _padding: [3]u8, // Padding for 4-byte alignment.
};

pub const PackedPhysicsSetPositionEvent = extern struct {
    id1: i64, // Primary ID of the body.
    id2: i64, // Secondary ID of the body.
    positionX: f64, // New X position.
    positionY: f64, // New Y position.
};

pub const PackedPhysicsSetRotationEvent = extern struct {
    id1: i64, // Primary ID of the body.
    id2: i64, // Secondary ID of the body.
    angleInRadians: f64, // New angle in radians.
};

pub const PackedPhysicsSetVelocityEvent = extern struct {
    id1: i64, // Primary ID of the body.
    id2: i64, // Secondary ID of the body.
    velocityX: f64, // New X velocity.
    velocityY: f64, // New Y velocity.
};

pub const PackedPhysicsSyncTransformEvent = extern struct {
    id1: i64, // Primary ID of the body.
    id2: i64, // Secondary ID of the body.
    positionX: f64, // Current X position.
    positionY: f64, // Current Y position.
    angle: f64, // Current rotation (in radians).
    velocityX: f64, // Current X velocity.
    velocityY: f64, // Current Y velocity.
    angularVelocity: f64, // Current angular velocity (spin speed) in radians/sec.
    isSleeping: u8, // 1 if the body is sleeping, 0 if active.
    _padding: [7]u8, // Aligns struct to 64-bit boundary.
};

pub const PackedPluginEventStackingEvent = extern struct {
    eventId: u8, // 1 to enable stacking, 0 to disable.
    _padding: u8, // Padding for alignment.
};

pub const PackedPluginLoadHeaderEvent = extern struct {
    channelNo: u32, // Initial Channel number to receive events from. Look at channel subscription event to listen to more than one channel.
    pathLength: u32, // Length of the plugin file path that follows.
};

pub const PackedPluginOnEvent = extern struct {
    eventId: u8, // A custom event ID for the plugin.
};

pub const PackedPluginSetEvent = extern struct {
    pluginId: u8, // ID of the plugin to set as active.
};

pub const PackedPluginSubscribeEvent = extern struct {
    pluginId: u8, // ID of the plugin.
    _padding: [3]u8, // Padding for alignment.
    channelNo: u32, // Channel number to receive events from.
};

pub const PackedPluginUnloadEvent = extern struct {
    pluginId: u8, // ID of the plugin to unload.
};

pub const PackedPluginUnsubscribeEvent = extern struct {
    pluginId: u8, // ID of the plugin.
    _padding: [3]u8, // Padding for alignment.
    channelNo: u32, // Channel number to stop receiving events from.
};

pub const PackedScriptSubscribeEvent = extern struct {
    channelNo: u32, // Channel number to start receiving events from.
    _padding: u32, // Padding for alignment.
};

pub const PackedScriptUnsubscribeEvent = extern struct {
    channelNo: u32, // Channel number to stop receiving events from.
    _padding: u32, // Padding for alignment.
};

pub const PackedSpriteAddEvent = extern struct {
    id1: i64, // Primary identifier (e.g., entity ID).
    id2: i64, // Secondary identifier (e.g., component ID).
    positionX: f64, // Initial X position.
    positionY: f64, // Initial Y position.
    positionZ: f64, // Initial Z position (depth).
    scaleX: f64, // Initial X scale.
    scaleY: f64, // Initial Y scale.
    scaleZ: f64, // Initial Z scale.
    sizeW: f64, // Initial width.
    sizeH: f64, // Initial height.
    rotationX: f64, // Initial X rotation (in radians).
    rotationY: f64, // Initial Y rotation (in radians).
    rotationZ: f64, // Initial Z rotation (in radians).
    r: u8, // Red color component (0-255).
    g: u8, // Green color component (0-255).
    b: u8, // Blue color component (0-255).
    a: u8, // Alpha color component (0-255).
    _padding: u32, // Ensures 8-byte alignment for speeds.
    speedX: f64, // Initial X speed.
    speedY: f64, // Initial Y speed.
};

pub const PackedSpriteColorEvent = extern struct {
    id1: i64, // Primary ID of the sprite.
    id2: i64, // Secondary ID of the sprite.
    r: u8, // New red component (0-255).
    g: u8, // New green component (0-255).
    b: u8, // New blue component (0-255).
    a: u8, // New alpha component (0-255).
    _padding: u32, // Padding for alignment.
};

pub const PackedSpriteMoveEvent = extern struct {
    id1: i64, // Primary ID of the sprite.
    id2: i64, // Secondary ID of the sprite.
    positionX: f64, // New X position.
    positionY: f64, // New Y position.
    positionZ: f64, // New Z position (depth).
};

pub const PackedSpriteRemoveEvent = extern struct {
    id1: i64, // Primary ID of sprite to remove.
    id2: i64, // Secondary ID of sprite to remove.
};

pub const PackedSpriteResizeEvent = extern struct {
    id1: i64, // Primary ID of the sprite.
    id2: i64, // Secondary ID of the sprite.
    sizeW: f64, // New width.
    sizeH: f64, // New height.
};

pub const PackedSpriteRotateEvent = extern struct {
    id1: i64, // Primary ID of the sprite.
    id2: i64, // Secondary ID of the sprite.
    rotationX: f64, // New X rotation (in radians).
    rotationY: f64, // New Y rotation (in radians).
    rotationZ: f64, // New Z rotation (in radians).
};

pub const PackedSpriteScaleEvent = extern struct {
    id1: i64, // Primary ID of the sprite.
    id2: i64, // Secondary ID of the sprite.
    scaleX: f64, // New X scale.
    scaleY: f64, // New Y scale.
    scaleZ: f64, // New Z scale.
};

pub const PackedSpriteSetSourceRectEvent = extern struct {
    id1: i64, // Primary ID of the sprite.
    id2: i64, // Secondary ID of the sprite.
    x: f32, // Source rect X coordinate.
    y: f32, // Source rect Y coordinate.
    w: f32, // Source rect Width.
    h: f32, // Source rect Height.
};

pub const PackedSpriteSpeedEvent = extern struct {
    id1: i64, // Primary ID of the sprite.
    id2: i64, // Secondary ID of the sprite.
    speedX: f64, // New X speed.
    speedY: f64, // New Y speed.
};

pub const PackedSpriteTextureSetEvent = extern struct {
    id1: i64, // Primary ID of the sprite.
    id2: i64, // Secondary ID of the sprite.
    textureId: u64, // The ID of the loaded texture to set.
};

pub const PackedTextAddEvent = extern struct {
    id1: i64, // Primary identifier.
    id2: i64, // Secondary identifier.
    positionX: f64, // Initial X position.
    positionY: f64, // Initial Y position.
    positionZ: f64, // Initial Z position (depth).
    r: u8, // Red color component (0-255).
    g: u8, // Green color component (0-255).
    b: u8, // Blue color component (0-255).
    a: u8, // Alpha color component (0-255).
    _padding1: u32, // Padding for alignment.
    fontSize: f32, // Font size.
    fontPathLength: u32, // Length of the font path string that follows.
    textLength: u32, // Length of the initial text string that follows.
    _padding2: u32, // Padding.
};

pub const PackedTextSetStringEvent = extern struct {
    id1: i64, // Primary ID of the text entity.
    id2: i64, // Secondary ID of the text entity.
    textLength: u32, // Length of the new text string that follows this header.
    _padding: u32, // Padding for alignment.
};

pub const PackedTextureLoadHeaderEvent = extern struct {
    id1: i64, // ID of the sprite this texture is for.
    id2: i64, // Secondary ID.
    filenameLength: u32, // Length of the texture filename that follows this header.
    _padding: u32, // Padding for alignment.
};

pub const PackedUIBeginWindowHeaderEvent = extern struct {
    id: u32, // ImGui Window Id.
    flags: u32, // ImGui Window flags.
    titleLength: u32, // Length of title.
    _padding: u32, // Padding to align header to 16 bytes.
};

pub const PackedUIButtonHeaderEvent = extern struct {
    id: u32, // Unique ID for this button to track clicks.
    w: f32, // Button width (0 for auto).
    h: f32, // Button height (0 for auto).
    labelLength: u32, // Length of the label string that follows.
};

pub const PackedUIEndWindowEvent = extern struct {
    _unused: u8, // Padding to ensure non-zero struct size.
};

pub const PackedUIInteractionEvent = extern struct {
    elementId: u32, // The ID of the element that was clicked.
    interactionType: u32, // Type of interaction (0 = Click, etc).
};

pub const PackedUISetNextWindowPosEvent = extern struct {
    x: f32, // X Position.
    y: f32, // Y Position.
    cond: u32, // ImGuiCond (Always=1, Once=2, FirstUseEver=4).
    pivotX: f32, // Pivot X (0.0=Left, 0.5=Center, 1.0=Right).
    pivotY: f32, // Pivot Y (0.0=Top, 0.5=Center, 1.0=Bottom).
};

pub const PackedUISetNextWindowSizeEvent = extern struct {
    w: f32, // Width.
    h: f32, // Height.
    cond: u32, // ImGuiCond (Always=1, Once=2, FirstUseEver=4).
};

pub const PackedUITextHeaderEvent = extern struct {
    textLength: u32, // Length of the text string that follows.
    _padding: u32, // Padding for alignment.
};

pub const PackedUIWindowClosedEvent = extern struct {
    windowId: u32, // The ID of the window that closed.
};

pub const PackedWindowFlagsEvent = extern struct {
    flags: u64, // Bitmask of window flags.
};

pub const PackedWindowResizeEvent = extern struct {
    w: i32, // New window width.
    h: i32, // New window height.
};

pub const PackedWindowTitleEvent = extern struct {
    title: @Vector(256, u8), // A fixed-size 256-byte NUL-padded string for the title.
};

pub const KVPair = struct { []const u8, u32 };

pub const event_payload_list = [_]KVPair{
    .{ "spriteAdd", @sizeOf(PackedSpriteAddEvent) },
    .{ "spriteRemove", @sizeOf(PackedSpriteRemoveEvent) },
    .{ "spriteMove", @sizeOf(PackedSpriteMoveEvent) },
    .{ "spriteScale", @sizeOf(PackedSpriteScaleEvent) },
    .{ "spriteResize", @sizeOf(PackedSpriteResizeEvent) },
    .{ "spriteRotate", @sizeOf(PackedSpriteRotateEvent) },
    .{ "spriteColor", @sizeOf(PackedSpriteColorEvent) },
    .{ "spriteSpeed", @sizeOf(PackedSpriteSpeedEvent) },
    .{ "spriteTextureLoad", @sizeOf(PackedTextureLoadHeaderEvent) },
    .{ "spriteTextureSet", @sizeOf(PackedSpriteTextureSetEvent) },
    .{ "spriteSetSourceRect", @sizeOf(PackedSpriteSetSourceRectEvent) },
    .{ "geomAddPoint", @sizeOf(PackedGeomAddPointEvent) },
    .{ "geomAddLine", @sizeOf(PackedGeomAddLineEvent) },
    .{ "geomAddRect", @sizeOf(PackedGeomAddRectEvent) },
    .{ "geomAddFillRect", @sizeOf(PackedGeomAddRectEvent) },
    .{ "geomAddPacked", @sizeOf(PackedGeomAddPackedHeaderEvent) },
    .{ "geomRemove", @sizeOf(PackedGeomRemoveEvent) },
    .{ "geomSetColor", @sizeOf(PackedGeomSetColorEvent) },

    // Input Events
    .{ "inputKeyup", @sizeOf(PackedKeyEvent) },
    .{ "inputKeydown", @sizeOf(PackedKeyEvent) },
    .{ "inputMouseup", @sizeOf(PackedMouseButtonEvent) },
    .{ "inputMousedown", @sizeOf(PackedMouseButtonEvent) },
    .{ "inputMousemotion", @sizeOf(PackedMouseMotionEvent) },

    // Window Events
    .{ "windowTitle", @sizeOf(PackedWindowTitleEvent) },
    .{ "windowResize", @sizeOf(PackedWindowResizeEvent) },
    .{ "windowFlags", @sizeOf(PackedWindowFlagsEvent) },

    // Text Events
    .{ "textAdd", @sizeOf(PackedTextAddEvent) },
    .{ "textSetString", @sizeOf(PackedTextSetStringEvent) },

    // Audio Events
    .{ "audioLoad", @sizeOf(PackedAudioLoadEvent) },
    .{ "audioLoaded", @sizeOf(PackedAudioLoadedEvent) },
    .{ "audioPlay", @sizeOf(PackedAudioPlayEvent) },
    .{ "audioStopAll", @sizeOf(PackedAudioStopAllEvent) },
    .{ "audioSetMasterVolume", @sizeOf(PackedAudioSetMasterVolumeEvent) },
    .{ "audioPause", @sizeOf(PackedAudioPauseEvent) },
    .{ "audioStop", @sizeOf(PackedAudioStopEvent) },
    .{ "audioUnload", @sizeOf(PackedAudioUnloadEvent) },
    .{ "audioSetVolume", @sizeOf(PackedAudioSetVolumeEvent) },

    // Physics Events
    .{ "physicsAddBody", @sizeOf(PackedPhysicsAddBodyEvent) },
    .{ "physicsRemoveBody", @sizeOf(PackedPhysicsRemoveBodyEvent) },
    .{ "physicsApplyForce", @sizeOf(PackedPhysicsApplyForceEvent) },
    .{ "physicsApplyImpulse", @sizeOf(PackedPhysicsApplyImpulseEvent) },
    .{ "physicsSetVelocity", @sizeOf(PackedPhysicsSetVelocityEvent) },
    .{ "physicsSetPosition", @sizeOf(PackedPhysicsSetPositionEvent) },
    .{ "physicsSetRotation", @sizeOf(PackedPhysicsSetRotationEvent) },
    .{ "physicsCollisionBegin", @sizeOf(PackedPhysicsCollisionEvent) },
    .{ "physicsCollisionSeparate", @sizeOf(PackedPhysicsCollisionEvent) },
    .{ "physicsSyncTransform", @sizeOf(PackedPhysicsSyncTransformEvent) },
    .{ "physicsSetDebugMode", @sizeOf(PackedPhysicsSetDebugModeEvent) },

    // Plugin Events
    .{ "plugin", @sizeOf(PackedPluginOnEvent) },
    .{ "pluginLoad", @sizeOf(PackedPluginLoadHeaderEvent) },
    .{ "pluginUnload", @sizeOf(PackedPluginUnloadEvent) },
    .{ "pluginSet", @sizeOf(PackedPluginSetEvent) },
    .{ "pluginEventStacking", @sizeOf(PackedPluginEventStackingEvent) },
    .{ "pluginSubscribeEvent", @sizeOf(PackedPluginSubscribeEvent) },
    .{ "pluginUnsubscribeEvent", @sizeOf(PackedPluginUnsubscribeEvent) },

    // Camera Events
    .{ "cameraSetPosition", @sizeOf(PackedCameraSetPositionEvent) },
    .{ "cameraMove", @sizeOf(PackedCameraMoveEvent) },
    .{ "cameraSetZoom", @sizeOf(PackedCameraSetZoomEvent) },
    .{ "cameraSetRotation", @sizeOf(PackedCameraSetRotationEvent) },
    .{ "cameraFollowEntity", @sizeOf(PackedCameraFollowEntityEvent) },
    .{ "cameraStopFollowing", @sizeOf(PackedCameraStopFollowingEvent) },

    // Script Events
    .{ "scriptSubscribe", @sizeOf(PackedScriptSubscribeEvent) },
    .{ "scriptUnsubscribe", @sizeOf(PackedScriptUnsubscribeEvent) },

    // Ui Events
    .{ "uiBeginWindow", @sizeOf(PackedUIBeginWindowHeaderEvent) },
    .{ "uiEndWindow", @sizeOf(PackedUIEndWindowEvent) },
    .{ "uiText", @sizeOf(PackedUITextHeaderEvent) },
    .{ "uiButton", @sizeOf(PackedUIButtonHeaderEvent) },
    .{ "uiSetNextWindowPos", @sizeOf(PackedUISetNextWindowPosEvent) },
    .{ "uiSetNextWindowSize", @sizeOf(PackedUISetNextWindowSizeEvent) },
    .{ "uiElementClicked", @sizeOf(PackedUIInteractionEvent) },
    .{ "uiWindowClosed", @sizeOf(PackedUIWindowClosedEvent) },
};

pub const event_payload_sizes = std.StaticStringMap(u32).initComptime(event_payload_list);

pub const Keycode = struct {
    pub const A: u32 = 97;
    pub const D: u32 = 100;
};

pub const CommandPacker = struct {
    writer: std.ArrayList(u8).Writer,
    command_count: u32 = 0,

    pub fn pack(self: *CommandPacker, event_type: Events, payload: anytype) !void {
        try self.writer.writeInt(u32, @intFromEnum(event_type), .little);
        try self.writer.writeInt(u64, 0, .little); // 8-byte timestamp
        try self.writer.writeAll(std.mem.asBytes(&payload));
        self.command_count += 1;
    }

    pub fn packTextureLoad(self: *CommandPacker, id1: i64, id2: i64, path: []const u8) !void {
        try self.writer.writeInt(u32, @intFromEnum(Events.spriteTextureLoad), .little);
        try self.writer.writeInt(u64, 0, .little);
        const header = PackedTextureLoadHeaderEvent{
            .id1 = id1,
            .id2 = id2,
            .filenameLength = @intCast(path.len),
            ._padding = 0,
        };
        try self.writer.writeAll(std.mem.asBytes(&header));
        try self.writer.writeAll(path);
        self.command_count += 1;
    }

    pub fn packPluginLoad(self: *CommandPacker, path: []const u8) !void {
        try self.writer.writeInt(u32, @intFromEnum(Events.pluginLoad), .little);
        try self.writer.writeInt(u64, 0, .little);
        const header = PackedPluginLoadHeaderEvent{
            .pathLength = @intCast(path.len),
        };
        try self.writer.writeAll(std.mem.asBytes(&header));
        try self.writer.writeAll(path);
        self.command_count += 1;
    }

    pub fn packAudioLoad(self: *CommandPacker, path: []const u8) !void {
        try self.writer.writeInt(u32, @intFromEnum(Events.audioLoad), .little);
        try self.writer.writeInt(u64, 0, .little);
        const header = PackedAudioLoadEvent{
            .pathLength = @intCast(path.len),
        };
        try self.writer.writeAll(std.mem.asBytes(&header));
        try self.writer.writeAll(path);
        self.command_count += 1;
    }

    pub fn packTextSetString(self: *CommandPacker, id1: i64, id2: i64, text: []const u8) !void {
        try self.writer.writeInt(u32, @intFromEnum(Events.textSetString), .little);
        try self.writer.writeInt(u64, 0, .little);

        const header = PackedTextSetStringEvent{
            .id1 = id1,
            .id2 = id2,
            .textLength = @intCast(text.len),
            ._padding = 0,
        };
        try self.writer.writeAll(std.mem.asBytes(&header));
        try self.writer.writeAll(text);
        self.command_count += 1;
    }

    pub fn packTextAdd(
        self: *CommandPacker,
        id1: i64, id2: i64,
        pos: [3]f64,
        color: [4]u8,
        font_size: f32,
        font_path: []const u8,
        text: []const u8,
    ) !void {
        try self.writer.writeInt(u32, @intFromEnum(Events.textAdd), .little);
        try self.writer.writeInt(u64, 0, .little);

        const header = PackedTextAddEvent{
            .id1 = id1,
            .id2 = id2,
            .positionX = pos[0],
            .positionY = pos[1],
            .positionZ = pos[2],
            .r = color[0],
            .g = color[1],
            .b = color[2],
            .a = color[3],
            ._padding1 = 0,
            .fontSize = font_size,
            .fontPathLength = @intCast(font_path.len),
            .textLength = @intCast(text.len),
            ._padding2 = 0,
        };
        try self.writer.writeAll(std.mem.asBytes(&header));
        try self.writer.writeAll(font_path);
        try self.writer.writeAll(text);
        self.command_count += 1;
    }
};

pub const EventUnpacker = struct {
    stream: std.io.FixedBufferStream([]const u8),

    pub fn init(blob: []const u8) EventUnpacker {
        return .{
            .stream = std.io.fixedBufferStream(blob),
        };
    }

    pub fn read(self: *EventUnpacker, comptime T: type) !T {
        return self.stream.reader().readInt(T, .little);
    }

    pub fn readPayload(self: *EventUnpacker, comptime T: type) !T {
        const bytes_array = try self.stream.reader().readBytesNoEof(@sizeOf(T));
        return std.mem.bytesAsValue(T, &bytes_array).*;
    }

    pub fn readVariable(self: *EventUnpacker, len: u32) ![]const u8 {
        return self.stream.reader().readBytesNoEof(len);
    }

    pub fn skip(self: *EventUnpacker, N: u32) !void {
        try self.stream.reader().skipBytes(@intCast(N), .{});
    }
};

pub fn hexdump_util(writer: anytype, slice: []const u8) anyerror!void {
    const ROW_SIZE = 16;
    var i: usize = 0;

    while (i < slice.len) : (i += ROW_SIZE) {
        const row_end = @min(i + ROW_SIZE, slice.len);
        const row = slice[i..row_end];

        try writer.print("{x:0>8} ", .{@as(u32, @intCast(i))});

        var j: usize = 0;
        while (j < ROW_SIZE) : (j += 1) {
            if (j < row.len) {
                try writer.print("{x:0>2} ", .{row[j]});
            } else {
                try writer.writeAll("   ");
            }
        }

        try writer.writeAll(" |");
        for (row) |byte| {
            if (byte >= 0x20 and byte <= 0x7E) {
                try writer.writeByte(byte);
            } else {
                try writer.writeByte('.');
            }
        }
        try writer.writeAll("|\n");
    }
}