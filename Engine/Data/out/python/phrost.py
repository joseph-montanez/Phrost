"""
// !!! THIS FILE IS AUTO-GENERATED BY PythonAdapter.php, DO NOT EDIT !!!
// Generated from: structs.json

"""

import enum
import random
import struct
import sys
from typing import Any, Callable, Dict, List, Optional, Tuple, Union

# --- Events Enum ---
class Events(enum.IntEnum):
    SPRITE_ADD = 0
    SPRITE_REMOVE = 1
    SPRITE_MOVE = 2
    SPRITE_SCALE = 3
    SPRITE_RESIZE = 4
    SPRITE_ROTATE = 5
    SPRITE_COLOR = 6
    SPRITE_SPEED = 7
    SPRITE_TEXTURE_LOAD = 8
    SPRITE_TEXTURE_SET = 9
    SPRITE_SET_SOURCE_RECT = 10
    GEOM_ADD_POINT = 50
    GEOM_ADD_LINE = 51
    GEOM_ADD_RECT = 52
    GEOM_ADD_FILL_RECT = 53
    GEOM_ADD_PACKED = 54
    GEOM_REMOVE = 55
    GEOM_SET_COLOR = 56

    INPUT_KEYUP = 100
    INPUT_KEYDOWN = 101
    INPUT_MOUSEUP = 102
    INPUT_MOUSEDOWN = 103
    INPUT_MOUSEMOTION = 104

    WINDOW_TITLE = 200
    WINDOW_RESIZE = 201
    WINDOW_FLAGS = 202

    TEXT_ADD = 300
    TEXT_SET_STRING = 301

    AUDIO_LOAD = 400
    AUDIO_LOADED = 401
    AUDIO_PLAY = 402
    AUDIO_STOP_ALL = 403
    AUDIO_SET_MASTER_VOLUME = 404
    AUDIO_PAUSE = 405
    AUDIO_STOP = 406
    AUDIO_UNLOAD = 407
    AUDIO_SET_VOLUME = 408

    PHYSICS_ADD_BODY = 500
    PHYSICS_REMOVE_BODY = 501
    PHYSICS_APPLY_FORCE = 502
    PHYSICS_APPLY_IMPULSE = 503
    PHYSICS_SET_VELOCITY = 504
    PHYSICS_SET_POSITION = 505
    PHYSICS_SET_ROTATION = 506
    PHYSICS_COLLISION_BEGIN = 550
    PHYSICS_COLLISION_SEPARATE = 551
    PHYSICS_SYNC_TRANSFORM = 552
    PHYSICS_SET_DEBUG_MODE = 553

    PLUGIN = 1000
    PLUGIN_LOAD = 1001
    PLUGIN_UNLOAD = 1002
    PLUGIN_SET = 1003
    PLUGIN_EVENT_STACKING = 1004
    PLUGIN_SUBSCRIBE_EVENT = 1005
    PLUGIN_UNSUBSCRIBE_EVENT = 1006

    CAMERA_SET_POSITION = 2000
    CAMERA_MOVE = 2001
    CAMERA_SET_ZOOM = 2002
    CAMERA_SET_ROTATION = 2003
    CAMERA_FOLLOW_ENTITY = 2004
    CAMERA_STOP_FOLLOWING = 2005

    SCRIPT_SUBSCRIBE = 3000
    SCRIPT_UNSUBSCRIBE = 3001
# --- End Events Enum ---

# --- Pack Format Classes ---
class SpritePackFormats:
    """
    Maps to Swift: `PackedSpriteAddEvent`
    - id1: i64 (Primary identifier (e.g., entity ID).)
    - id2: i64 (Secondary identifier (e.g., component ID).)
    - positionX: f64 (Initial X position.)
    - positionY: f64 (Initial Y position.)
    - positionZ: f64 (Initial Z position (depth).)
    - scaleX: f64 (Initial X scale.)
    - scaleY: f64 (Initial Y scale.)
    - scaleZ: f64 (Initial Z scale.)
    - sizeW: f64 (Initial width.)
    - sizeH: f64 (Initial height.)
    - rotationX: f64 (Initial X rotation (in radians).)
    - rotationY: f64 (Initial Y rotation (in radians).)
    - rotationZ: f64 (Initial Z rotation (in radians).)
    - r: u8 (Red color component (0-255).)
    - g: u8 (Green color component (0-255).)
    - b: u8 (Blue color component (0-255).)
    - a: u8 (Alpha color component (0-255).)
    - _padding: u32 (Ensures 8-byte alignment for speeds.)
    - speedX: f64 (Initial X speed.)
    - speedY: f64 (Initial Y speed.)
    """
    # Format: <qqdddddddddddBBBB4xdd
    # Size: 128 bytes
    PACK_SPRITE_ADD: Tuple[str, int] = ("<qqdddddddddddBBBB4xdd", 128)

    """
    Maps to Swift: `PackedSpriteRemoveEvent`
    - id1: i64 (Primary ID of sprite to remove.)
    - id2: i64 (Secondary ID of sprite to remove.)
    """
    # Format: <qq
    # Size: 16 bytes
    PACK_SPRITE_REMOVE: Tuple[str, int] = ("<qq", 16)

    """
    Maps to Swift: `PackedSpriteMoveEvent`
    - id1: i64 (Primary ID of the sprite.)
    - id2: i64 (Secondary ID of the sprite.)
    - positionX: f64 (New X position.)
    - positionY: f64 (New Y position.)
    - positionZ: f64 (New Z position (depth).)
    """
    # Format: <qqddd
    # Size: 40 bytes
    PACK_SPRITE_MOVE: Tuple[str, int] = ("<qqddd", 40)

    """
    Maps to Swift: `PackedSpriteScaleEvent`
    - id1: i64 (Primary ID of the sprite.)
    - id2: i64 (Secondary ID of the sprite.)
    - scaleX: f64 (New X scale.)
    - scaleY: f64 (New Y scale.)
    - scaleZ: f64 (New Z scale.)
    """
    # Format: <qqddd
    # Size: 40 bytes
    PACK_SPRITE_SCALE: Tuple[str, int] = ("<qqddd", 40)

    """
    Maps to Swift: `PackedSpriteResizeEvent`
    - id1: i64 (Primary ID of the sprite.)
    - id2: i64 (Secondary ID of the sprite.)
    - sizeW: f64 (New width.)
    - sizeH: f64 (New height.)
    """
    # Format: <qqdd
    # Size: 32 bytes
    PACK_SPRITE_RESIZE: Tuple[str, int] = ("<qqdd", 32)

    """
    Maps to Swift: `PackedSpriteRotateEvent`
    - id1: i64 (Primary ID of the sprite.)
    - id2: i64 (Secondary ID of the sprite.)
    - rotationX: f64 (New X rotation (in radians).)
    - rotationY: f64 (New Y rotation (in radians).)
    - rotationZ: f64 (New Z rotation (in radians).)
    """
    # Format: <qqddd
    # Size: 40 bytes
    PACK_SPRITE_ROTATE: Tuple[str, int] = ("<qqddd", 40)

    """
    Maps to Swift: `PackedSpriteColorEvent`
    - id1: i64 (Primary ID of the sprite.)
    - id2: i64 (Secondary ID of the sprite.)
    - r: u8 (New red component (0-255).)
    - g: u8 (New green component (0-255).)
    - b: u8 (New blue component (0-255).)
    - a: u8 (New alpha component (0-255).)
    - _padding: u32 (Padding for alignment.)
    """
    # Format: <qqBBBB4x
    # Size: 24 bytes
    PACK_SPRITE_COLOR: Tuple[str, int] = ("<qqBBBB4x", 24)

    """
    Maps to Swift: `PackedSpriteSpeedEvent`
    - id1: i64 (Primary ID of the sprite.)
    - id2: i64 (Secondary ID of the sprite.)
    - speedX: f64 (New X speed.)
    - speedY: f64 (New Y speed.)
    """
    # Format: <qqdd
    # Size: 32 bytes
    PACK_SPRITE_SPEED: Tuple[str, int] = ("<qqdd", 32)

    """
    Maps to Swift: `PackedTextureLoadHeaderEvent`
    (Header struct)
    - id1: i64 (ID of the sprite this texture is for.)
    - id2: i64 (Secondary ID.)
    - filenameLength: u32 (Length of the texture filename that follows this header.)
    - _padding: u32 (Padding for alignment.)
    """
    # Format: <qqI4x
    # Size: 24 bytes
    PACK_SPRITE_TEXTURE_LOAD: Tuple[str, int] = ("<qqI4x", 24)

    """
    Maps to Swift: `PackedSpriteTextureSetEvent`
    - id1: i64 (Primary ID of the sprite.)
    - id2: i64 (Secondary ID of the sprite.)
    - textureId: u64 (The ID of the loaded texture to set.)
    """
    # Format: <qqQ
    # Size: 24 bytes
    PACK_SPRITE_TEXTURE_SET: Tuple[str, int] = ("<qqQ", 24)

    """
    Maps to Swift: `PackedSpriteSetSourceRectEvent`
    - id1: i64 (Primary ID of the sprite.)
    - id2: i64 (Secondary ID of the sprite.)
    - x: f32 (Source rect X coordinate.)
    - y: f32 (Source rect Y coordinate.)
    - w: f32 (Source rect Width.)
    - h: f32 (Source rect Height.)
    """
    # Format: <qqffff
    # Size: 32 bytes
    PACK_SPRITE_SET_SOURCE_RECT: Tuple[str, int] = ("<qqffff", 32)

    """
    Maps to Swift: `PackedGeomAddPointEvent`
    - id1: i64 (Primary identifier.)
    - id2: i64 (Secondary identifier.)
    - z: f64 (Z position (depth).)
    - r: u8 (Red color component (0-255).)
    - g: u8 (Green color component (0-255).)
    - b: u8 (Blue color component (0-255).)
    - a: u8 (Alpha color component (0-255).)
    - isScreenSpace: u8 (If the geometry is unaffected by the camera.)
    - _padding: u8 (Padding for alignment.)
    - x: f32 (X coordinate.)
    - y: f32 (Y coordinate.)
    """
    # Format: <qqdBBBBB3xff
    # Size: 40 bytes
    PACK_GEOM_ADD_POINT: Tuple[str, int] = ("<qqdBBBBB3xff", 40)

    """
    Maps to Swift: `PackedGeomAddLineEvent`
    - id1: i64 (Primary identifier.)
    - id2: i64 (Secondary identifier.)
    - z: f64 (Z position (depth).)
    - r: u8 (Red color component (0-255).)
    - g: u8 (Green color component (0-255).)
    - b: u8 (Blue color component (0-255).)
    - a: u8 (Alpha color component (0-255).)
    - isScreenSpace: u8 (If the geometry is unaffected by the camera.)
    - _padding: u8 (Padding for alignment.)
    - x1: f32 (Start X coordinate.)
    - y1: f32 (Start Y coordinate.)
    - x2: f32 (End X coordinate.)
    - y2: f32 (End Y coordinate.)
    """
    # Format: <qqdBBBBB3xffff
    # Size: 48 bytes
    PACK_GEOM_ADD_LINE: Tuple[str, int] = ("<qqdBBBBB3xffff", 48)

    """
    Maps to Swift: `PackedGeomAddRectEvent`
    - id1: i64 (Primary identifier.)
    - id2: i64 (Secondary identifier.)
    - z: f64 (Z position (depth).)
    - r: u8 (Red color component (0-255).)
    - g: u8 (Green color component (0-255).)
    - b: u8 (Blue color component (0-255).)
    - a: u8 (Alpha color component (0-255).)
    - isScreenSpace: u8 (If the geometry is unaffected by the camera.)
    - _padding: u8 (Padding for alignment.)
    - x: f32 (Top-left X coordinate.)
    - y: f32 (Top-left Y coordinate.)
    - w: f32 (Width.)
    - h: f32 (Height.)
    """
    # Format: <qqdBBBBB3xffff
    # Size: 48 bytes
    PACK_GEOM_ADD_RECT: Tuple[str, int] = ("<qqdBBBBB3xffff", 48)

    """
    Maps to Swift: `PackedGeomAddRectEvent`
    - id1: i64 (Primary identifier.)
    - id2: i64 (Secondary identifier.)
    - z: f64 (Z position (depth).)
    - r: u8 (Red color component (0-255).)
    - g: u8 (Green color component (0-255).)
    - b: u8 (Blue color component (0-255).)
    - a: u8 (Alpha color component (0-255).)
    - isScreenSpace: u8 (If the geometry is unaffected by the camera.)
    - _padding: u8 (Padding for alignment.)
    - x: f32 (Top-left X coordinate.)
    - y: f32 (Top-left Y coordinate.)
    - w: f32 (Width.)
    - h: f32 (Height.)
    """
    # Format: <qqdBBBBB3xffff
    # Size: 48 bytes
    PACK_GEOM_ADD_FILL_RECT: Tuple[str, int] = ("<qqdBBBBB3xffff", 48)

    """
    Maps to Swift: `PackedGeomAddPackedHeaderEvent`
    (Header struct)
    - id1: i64 (Primary identifier.)
    - id2: i64 (Secondary identifier.)
    - z: f64 (Z position (depth).)
    - r: u8 (Red color component (0-255).)
    - g: u8 (Green color component (0-255).)
    - b: u8 (Blue color component (0-255).)
    - a: u8 (Alpha color component (0-255).)
    - isScreenSpace: u8 (If the geometry is unaffected by the camera.)
    - _padding: u16 (Padding for alignment.)
    - primitiveType: u32 (Raw value from PrimitiveType enum (point, line, rect).)
    - count: u32 (Number of primitives that follow this header.)
    """
    # Format: <qqdBBBBB2xII
    # Size: 39 bytes
    PACK_GEOM_ADD_PACKED: Tuple[str, int] = ("<qqdBBBBB2xII", 39)

    """
    Maps to Swift: `PackedGeomRemoveEvent`
    - id1: i64 (Primary ID of geometry to remove.)
    - id2: i64 (Secondary ID of geometry to remove.)
    """
    # Format: <qq
    # Size: 16 bytes
    PACK_GEOM_REMOVE: Tuple[str, int] = ("<qq", 16)

    """
    Maps to Swift: `PackedGeomSetColorEvent`
    - id1: i64 (Primary ID of the geometry entity.)
    - id2: i64 (Secondary ID of the geometry entity.)
    - r: u8 (New red component (0-255).)
    - g: u8 (New green component (0-255).)
    - b: u8 (New blue component (0-255).)
    - a: u8 (New alpha component (0-255).)
    - _padding: u32 (Padding for alignment.)
    """
    # Format: <qqBBBB4x
    # Size: 24 bytes
    PACK_GEOM_SET_COLOR: Tuple[str, int] = ("<qqBBBB4x", 24)

class InputPackFormats:
    """
    Maps to Swift: `PackedKeyEvent`
    - scancode: i32 (Physical key scancode.)
    - keycode: u32 (Keycode (e.g., Keycode.A).)
    - mod: u16 (Key modifiers (Shift, Ctrl, etc.).)
    - isRepeat: u8 (1 if this is a key repeat, 0 otherwise.)
    - _padding: u8 (Padding for alignment.)
    """
    # Format: <iIHBx
    # Size: 12 bytes
    PACK_INPUT_KEYUP: Tuple[str, int] = ("<iIHBx", 12)

    """
    Maps to Swift: `PackedKeyEvent`
    - scancode: i32 (Physical key scancode.)
    - keycode: u32 (Keycode (e.g., Keycode.A).)
    - mod: u16 (Key modifiers (Shift, Ctrl, etc.).)
    - isRepeat: u8 (1 if this is a key repeat, 0 otherwise.)
    - _padding: u8 (Padding for alignment.)
    """
    # Format: <iIHBx
    # Size: 12 bytes
    PACK_INPUT_KEYDOWN: Tuple[str, int] = ("<iIHBx", 12)

    """
    Maps to Swift: `PackedMouseButtonEvent`
    - x: f32 (X coordinate of the mouse.)
    - y: f32 (Y coordinate of the mouse.)
    - button: u8 (Mouse button index.)
    - clicks: u8 (Number of clicks (1 for single, 2 for double).)
    - _padding: u16 (Padding for alignment.)
    """
    # Format: <ffBB2x
    # Size: 12 bytes
    PACK_INPUT_MOUSEUP: Tuple[str, int] = ("<ffBB2x", 12)

    """
    Maps to Swift: `PackedMouseButtonEvent`
    - x: f32 (X coordinate of the mouse.)
    - y: f32 (Y coordinate of the mouse.)
    - button: u8 (Mouse button index.)
    - clicks: u8 (Number of clicks (1 for single, 2 for double).)
    - _padding: u16 (Padding for alignment.)
    """
    # Format: <ffBB2x
    # Size: 12 bytes
    PACK_INPUT_MOUSEDOWN: Tuple[str, int] = ("<ffBB2x", 12)

    """
    Maps to Swift: `PackedMouseMotionEvent`
    - x: f32 (Absolute X coordinate.)
    - y: f32 (Absolute Y coordinate.)
    - xrel: f32 (Relative X motion.)
    - yrel: f32 (Relative Y motion.)
    """
    # Format: <ffff
    # Size: 16 bytes
    PACK_INPUT_MOUSEMOTION: Tuple[str, int] = ("<ffff", 16)

class WindowPackFormats:
    """
    Maps to Swift: `PackedWindowTitleEvent`
    - title: char[256] (A fixed-size 256-byte NUL-padded string for the title.)
    """
    # Format: <256s
    # Size: 256 bytes
    PACK_WINDOW_TITLE: Tuple[str, int] = ("<256s", 256)

    """
    Maps to Swift: `PackedWindowResizeEvent`
    - w: i32 (New window width.)
    - h: i32 (New window height.)
    """
    # Format: <ii
    # Size: 8 bytes
    PACK_WINDOW_RESIZE: Tuple[str, int] = ("<ii", 8)

    """
    Maps to Swift: `PackedWindowFlagsEvent`
    - flags: u64 (Bitmask of window flags.)
    """
    # Format: <Q
    # Size: 8 bytes
    PACK_WINDOW_FLAGS: Tuple[str, int] = ("<Q", 8)

class TextPackFormats:
    """
    Maps to Swift: `PackedTextAddEvent`
    (Header struct)
    - id1: i64 (Primary identifier.)
    - id2: i64 (Secondary identifier.)
    - positionX: f64 (Initial X position.)
    - positionY: f64 (Initial Y position.)
    - positionZ: f64 (Initial Z position (depth).)
    - r: u8 (Red color component (0-255).)
    - g: u8 (Green color component (0-255).)
    - b: u8 (Blue color component (0-255).)
    - a: u8 (Alpha color component (0-255).)
    - _padding1: u32 (Padding for alignment.)
    - fontSize: f32 (Font size.)
    - fontPathLength: u32 (Length of the font path string that follows.)
    - textLength: u32 (Length of the initial text string that follows.)
    - _padding2: u32 (Padding.)
    """
    # Format: <qqdddBBBB4xfII4x
    # Size: 64 bytes
    PACK_TEXT_ADD: Tuple[str, int] = ("<qqdddBBBB4xfII4x", 64)

    """
    Maps to Swift: `PackedTextSetStringEvent`
    (Header struct)
    - id1: i64 (Primary ID of the text entity.)
    - id2: i64 (Secondary ID of the text entity.)
    - textLength: u32 (Length of the new text string that follows this header.)
    - _padding: u32 (Padding for alignment.)
    """
    # Format: <qqI4x
    # Size: 24 bytes
    PACK_TEXT_SET_STRING: Tuple[str, int] = ("<qqI4x", 24)

class AudioPackFormats:
    """
    Maps to Swift: `PackedAudioLoadEvent`
    (Header struct)
    - pathLength: u32 (Length of the audio file path that follows.)
    """
    # Format: <I
    # Size: 4 bytes
    PACK_AUDIO_LOAD: Tuple[str, int] = ("<I", 4)

    """
    Maps to Swift: `PackedAudioLoadedEvent`
    - audioId: u64 (The ID assigned to the loaded audio.)
    """
    # Format: <Q
    # Size: 8 bytes
    PACK_AUDIO_LOADED: Tuple[str, int] = ("<Q", 8)

    """
    Maps to Swift: `PackedAudioPlayEvent`
    - audioId: u64 (The ID of the audio to play.)
    """
    # Format: <Q
    # Size: 8 bytes
    PACK_AUDIO_PLAY: Tuple[str, int] = ("<Q", 8)

    """
    Maps to Swift: `PackedAudioStopAllEvent`
    - _unused: u8 (Padding to ensure non-zero struct size (MSVC compatibility).)
    """
    # Format: <B
    # Size: 1 bytes
    PACK_AUDIO_STOP_ALL: Tuple[str, int] = ("<B", 1)

    """
    Maps to Swift: `PackedAudioSetMasterVolumeEvent`
    - volume: f32 (Volume level (e.g., 0.0 to 1.0).)
    """
    # Format: <f
    # Size: 4 bytes
    PACK_AUDIO_SET_MASTER_VOLUME: Tuple[str, int] = ("<f", 4)

    """
    Maps to Swift: `PackedAudioPauseEvent`
    - audioId: u64 (The ID of the audio to pause.)
    """
    # Format: <Q
    # Size: 8 bytes
    PACK_AUDIO_PAUSE: Tuple[str, int] = ("<Q", 8)

    """
    Maps to Swift: `PackedAudioStopEvent`
    - audioId: u64 (The ID of the audio to stop.)
    """
    # Format: <Q
    # Size: 8 bytes
    PACK_AUDIO_STOP: Tuple[str, int] = ("<Q", 8)

    """
    Maps to Swift: `PackedAudioUnloadEvent`
    - audioId: u64 (The ID of the audio to unload.)
    """
    # Format: <Q
    # Size: 8 bytes
    PACK_AUDIO_UNLOAD: Tuple[str, int] = ("<Q", 8)

    """
    Maps to Swift: `PackedAudioSetVolumeEvent`
    - audioId: u64 (The ID of the audio to modify.)
    - volume: f32 (Volume level (0.0 to 1.0).)
    - _padding: u32 (Padding for alignment.)
    """
    # Format: <Qf4x
    # Size: 16 bytes
    PACK_AUDIO_SET_VOLUME: Tuple[str, int] = ("<Qf4x", 16)

class PhysicsPackFormats:
    """
    Maps to Swift: `PackedPhysicsAddBodyEvent`
    - id1: i64 (Primary identifier.)
    - id2: i64 (Secondary identifier.)
    - positionX: f64 (Initial X position.)
    - positionY: f64 (Initial Y position.)
    - bodyType: u8 (Body type (static, kinematic, dynamic).)
    - shapeType: u8 (Shape type (box, circle).)
    - lockRotation: u8 (Rotation lock (0 = unlocked, 1 = locked). Prevent bodies from falling over.)
    - _padding: u8 (Padding for 8-byte alignment.)
    - mass: f64 (Mass of the body.)
    - friction: f64 (Friction coefficient.)
    - elasticity: f64 (Elasticity (bounciness).)
    - width: f64 (Width of the shape (or radius).)
    - height: f64 (Height of the shape (unused if circle).)
    """
    # Format: <qqddBBB5xddddd
    # Size: 80 bytes
    PACK_PHYSICS_ADD_BODY: Tuple[str, int] = ("<qqddBBB5xddddd", 80)

    """
    Maps to Swift: `PackedPhysicsRemoveBodyEvent`
    - id1: i64 (Primary ID of body to remove.)
    - id2: i64 (Secondary ID of body to remove.)
    """
    # Format: <qq
    # Size: 16 bytes
    PACK_PHYSICS_REMOVE_BODY: Tuple[str, int] = ("<qq", 16)

    """
    Maps to Swift: `PackedPhysicsApplyForceEvent`
    - id1: i64 (Primary ID of the body.)
    - id2: i64 (Secondary ID of the body.)
    - forceX: f64 (Force vector X component.)
    - forceY: f64 (Force vector Y component.)
    """
    # Format: <qqdd
    # Size: 32 bytes
    PACK_PHYSICS_APPLY_FORCE: Tuple[str, int] = ("<qqdd", 32)

    """
    Maps to Swift: `PackedPhysicsApplyImpulseEvent`
    - id1: i64 (Primary ID of the body.)
    - id2: i64 (Secondary ID of the body.)
    - impulseX: f64 (Impulse vector X component.)
    - impulseY: f64 (Impulse vector Y component.)
    """
    # Format: <qqdd
    # Size: 32 bytes
    PACK_PHYSICS_APPLY_IMPULSE: Tuple[str, int] = ("<qqdd", 32)

    """
    Maps to Swift: `PackedPhysicsSetVelocityEvent`
    - id1: i64 (Primary ID of the body.)
    - id2: i64 (Secondary ID of the body.)
    - velocityX: f64 (New X velocity.)
    - velocityY: f64 (New Y velocity.)
    """
    # Format: <qqdd
    # Size: 32 bytes
    PACK_PHYSICS_SET_VELOCITY: Tuple[str, int] = ("<qqdd", 32)

    """
    Maps to Swift: `PackedPhysicsSetPositionEvent`
    - id1: i64 (Primary ID of the body.)
    - id2: i64 (Secondary ID of the body.)
    - positionX: f64 (New X position.)
    - positionY: f64 (New Y position.)
    """
    # Format: <qqdd
    # Size: 32 bytes
    PACK_PHYSICS_SET_POSITION: Tuple[str, int] = ("<qqdd", 32)

    """
    Maps to Swift: `PackedPhysicsSetRotationEvent`
    - id1: i64 (Primary ID of the body.)
    - id2: i64 (Secondary ID of the body.)
    - angleInRadians: f64 (New angle in radians.)
    """
    # Format: <qqd
    # Size: 24 bytes
    PACK_PHYSICS_SET_ROTATION: Tuple[str, int] = ("<qqd", 24)

    """
    Maps to Swift: `PackedPhysicsCollisionEvent`
    - id1_A: i64 (Primary ID of the first body.)
    - id2_A: i64 (Secondary ID of the first body.)
    - id1_B: i64 (Primary ID of the second body.)
    - id2_B: i64 (Secondary ID of the second body.)
    """
    # Format: <qqqq
    # Size: 32 bytes
    UNPACK_PHYSICS_COLLISION: Tuple[str, int] = ("<qqqq", 32)

    """
    Maps to Swift: `PackedPhysicsSyncTransformEvent`
    - id1: i64 (Primary ID of the body.)
    - id2: i64 (Secondary ID of the body.)
    - positionX: f64 (Current X position.)
    - positionY: f64 (Current Y position.)
    - angle: f64 (Current rotation (in radians).)
    - velocityX: f64 (Current X velocity.)
    - velocityY: f64 (Current Y velocity.)
    - angularVelocity: f64 (Current angular velocity (spin speed) in radians/sec.)
    - isSleeping: u8 (1 if the body is sleeping, 0 if active.)
    - _padding: u8 (Aligns struct to 64-bit boundary.)
    """
    # Format: <qqddddddB7x
    # Size: 72 bytes
    UNPACK_PHYSICS_SYNC_TRANSFORM: Tuple[str, int] = ("<qqddddddB7x", 72)

    """
    Maps to Swift: `PackedPhysicsSetDebugModeEvent`
    - enabled: u8 (1 to enable debug drawing, 0 to disable.)
    - _padding: u8 (Padding for 4-byte alignment.)
    """
    # Format: <B3x
    # Size: 4 bytes
    PACK_PHYSICS_SET_DEBUG_MODE: Tuple[str, int] = ("<B3x", 4)

class PluginPackFormats:
    """
    Maps to Swift: `PackedPluginOnEvent`
    - eventId: u8 (A custom event ID for the plugin.)
    """
    # Format: <B
    # Size: 1 bytes
    PACK_PLUGIN: Tuple[str, int] = ("<B", 1)

    """
    Maps to Swift: `PackedPluginLoadHeaderEvent`
    (Header struct)
    - channelNo: u32 (Initial Channel number to receive events from. Look at channel subscription event to listen to more than one channel.)
    - pathLength: u32 (Length of the plugin file path that follows.)
    """
    # Format: <II
    # Size: 8 bytes
    PACK_PLUGIN_LOAD: Tuple[str, int] = ("<II", 8)

    """
    Maps to Swift: `PackedPluginUnloadEvent`
    - pluginId: u8 (ID of the plugin to unload.)
    """
    # Format: <B
    # Size: 1 bytes
    PACK_PLUGIN_UNLOAD: Tuple[str, int] = ("<B", 1)

    """
    Maps to Swift: `PackedPluginSetEvent`
    - pluginId: u8 (ID of the plugin to set as active.)
    """
    # Format: <B
    # Size: 1 bytes
    PACK_PLUGIN_SET: Tuple[str, int] = ("<B", 1)

    """
    Maps to Swift: `PackedPluginEventStackingEvent`
    - eventId: u8 (1 to enable stacking, 0 to disable.)
    - _padding: u8 (Padding for alignment.)
    """
    # Format: <Bx
    # Size: 2 bytes
    PACK_PLUGIN_EVENT_STACKING: Tuple[str, int] = ("<Bx", 2)

    """
    Maps to Swift: `PackedPluginSubscribeEvent`
    - pluginId: u8 (ID of the plugin.)
    - _padding: u8 (Padding for alignment.)
    - channelNo: u32 (Channel number to receive events from.)
    """
    # Format: <B3xI
    # Size: 8 bytes
    PACK_PLUGIN_SUBSCRIBE_EVENT: Tuple[str, int] = ("<B3xI", 8)

    """
    Maps to Swift: `PackedPluginUnsubscribeEvent`
    - pluginId: u8 (ID of the plugin.)
    - _padding: u8 (Padding for alignment.)
    - channelNo: u32 (Channel number to stop receiving events from.)
    """
    # Format: <B3xI
    # Size: 8 bytes
    PACK_PLUGIN_UNSUBSCRIBE_EVENT: Tuple[str, int] = ("<B3xI", 8)

class CameraPackFormats:
    """
    Maps to Swift: `PackedCameraSetPositionEvent`
    - positionX: f64 (New X position for the camera's top-left corner.)
    - positionY: f64 (New Y position for the camera's top-left corner.)
    """
    # Format: <dd
    # Size: 16 bytes
    PACK_CAMERA_SET_POSITION: Tuple[str, int] = ("<dd", 16)

    """
    Maps to Swift: `PackedCameraMoveEvent`
    - deltaX: f64 (Amount to move the camera on the X axis.)
    - deltaY: f64 (Amount to move the camera on the Y axis.)
    """
    # Format: <dd
    # Size: 16 bytes
    PACK_CAMERA_MOVE: Tuple[str, int] = ("<dd", 16)

    """
    Maps to Swift: `PackedCameraSetZoomEvent`
    - zoom: f64 (New zoom level. 1.0 is default, 2.0 is zoomed in.)
    """
    # Format: <d
    # Size: 8 bytes
    PACK_CAMERA_SET_ZOOM: Tuple[str, int] = ("<d", 8)

    """
    Maps to Swift: `PackedCameraSetRotationEvent`
    - angleInRadians: f64 (New camera rotation in radians.)
    """
    # Format: <d
    # Size: 8 bytes
    PACK_CAMERA_SET_ROTATION: Tuple[str, int] = ("<d", 8)

    """
    Maps to Swift: `PackedCameraFollowEntityEvent`
    - id1: i64 (Primary ID of the entity to follow.)
    - id2: i64 (Secondary ID of the entity to follow.)
    """
    # Format: <qq
    # Size: 16 bytes
    PACK_CAMERA_FOLLOW_ENTITY: Tuple[str, int] = ("<qq", 16)

    """
    Maps to Swift: `PackedCameraStopFollowingEvent`
    - _unused: u8 (Padding to ensure non-zero struct size (MSVC compatibility).)
    """
    # Format: <B
    # Size: 1 bytes
    PACK_CAMERA_STOP_FOLLOWING: Tuple[str, int] = ("<B", 1)

class ScriptPackFormats:
    """
    Maps to Swift: `PackedScriptSubscribeEvent`
    - channelNo: u32 (Channel number to start receiving events from.)
    - _padding: u32 (Padding for alignment.)
    """
    # Format: <I4x
    # Size: 8 bytes
    PACK_SCRIPT_SUBSCRIBE: Tuple[str, int] = ("<I4x", 8)

    """
    Maps to Swift: `PackedScriptUnsubscribeEvent`
    - channelNo: u32 (Channel number to stop receiving events from.)
    - _padding: u32 (Padding for alignment.)
    """
    # Format: <I4x
    # Size: 8 bytes
    PACK_SCRIPT_UNSUBSCRIBE: Tuple[str, int] = ("<I4x", 8)# --- End Pack Format Classes ---

# --- PackFormat Class ---
class PackFormat:
    # This map holds the pre-computed (format, size) tuples
    _EVENT_FORMAT_MAP: Dict[int, Tuple[str, int]] = {
        Events.SPRITE_ADD.value: SpritePackFormats.PACK_SPRITE_ADD,
        Events.SPRITE_REMOVE.value: SpritePackFormats.PACK_SPRITE_REMOVE,
        Events.SPRITE_MOVE.value: SpritePackFormats.PACK_SPRITE_MOVE,
        Events.SPRITE_SCALE.value: SpritePackFormats.PACK_SPRITE_SCALE,
        Events.SPRITE_RESIZE.value: SpritePackFormats.PACK_SPRITE_RESIZE,
        Events.SPRITE_ROTATE.value: SpritePackFormats.PACK_SPRITE_ROTATE,
        Events.SPRITE_COLOR.value: SpritePackFormats.PACK_SPRITE_COLOR,
        Events.SPRITE_SPEED.value: SpritePackFormats.PACK_SPRITE_SPEED,
        Events.SPRITE_TEXTURE_LOAD.value: SpritePackFormats.PACK_SPRITE_TEXTURE_LOAD,
        Events.SPRITE_TEXTURE_SET.value: SpritePackFormats.PACK_SPRITE_TEXTURE_SET,
        Events.SPRITE_SET_SOURCE_RECT.value: SpritePackFormats.PACK_SPRITE_SET_SOURCE_RECT,
        Events.GEOM_ADD_POINT.value: SpritePackFormats.PACK_GEOM_ADD_POINT,
        Events.GEOM_ADD_LINE.value: SpritePackFormats.PACK_GEOM_ADD_LINE,
        Events.GEOM_ADD_RECT.value: SpritePackFormats.PACK_GEOM_ADD_RECT,
        Events.GEOM_ADD_FILL_RECT.value: SpritePackFormats.PACK_GEOM_ADD_FILL_RECT,
        Events.GEOM_ADD_PACKED.value: SpritePackFormats.PACK_GEOM_ADD_PACKED,
        Events.GEOM_REMOVE.value: SpritePackFormats.PACK_GEOM_REMOVE,
        Events.GEOM_SET_COLOR.value: SpritePackFormats.PACK_GEOM_SET_COLOR,
        Events.INPUT_KEYUP.value: InputPackFormats.PACK_INPUT_KEYUP,
        Events.INPUT_KEYDOWN.value: InputPackFormats.PACK_INPUT_KEYDOWN,
        Events.INPUT_MOUSEUP.value: InputPackFormats.PACK_INPUT_MOUSEUP,
        Events.INPUT_MOUSEDOWN.value: InputPackFormats.PACK_INPUT_MOUSEDOWN,
        Events.INPUT_MOUSEMOTION.value: InputPackFormats.PACK_INPUT_MOUSEMOTION,
        Events.WINDOW_TITLE.value: WindowPackFormats.PACK_WINDOW_TITLE,
        Events.WINDOW_RESIZE.value: WindowPackFormats.PACK_WINDOW_RESIZE,
        Events.WINDOW_FLAGS.value: WindowPackFormats.PACK_WINDOW_FLAGS,
        Events.TEXT_ADD.value: TextPackFormats.PACK_TEXT_ADD,
        Events.TEXT_SET_STRING.value: TextPackFormats.PACK_TEXT_SET_STRING,
        Events.AUDIO_LOAD.value: AudioPackFormats.PACK_AUDIO_LOAD,
        Events.AUDIO_LOADED.value: AudioPackFormats.PACK_AUDIO_LOADED,
        Events.AUDIO_PLAY.value: AudioPackFormats.PACK_AUDIO_PLAY,
        Events.AUDIO_STOP_ALL.value: AudioPackFormats.PACK_AUDIO_STOP_ALL,
        Events.AUDIO_SET_MASTER_VOLUME.value: AudioPackFormats.PACK_AUDIO_SET_MASTER_VOLUME,
        Events.AUDIO_PAUSE.value: AudioPackFormats.PACK_AUDIO_PAUSE,
        Events.AUDIO_STOP.value: AudioPackFormats.PACK_AUDIO_STOP,
        Events.AUDIO_UNLOAD.value: AudioPackFormats.PACK_AUDIO_UNLOAD,
        Events.AUDIO_SET_VOLUME.value: AudioPackFormats.PACK_AUDIO_SET_VOLUME,
        Events.PHYSICS_ADD_BODY.value: PhysicsPackFormats.PACK_PHYSICS_ADD_BODY,
        Events.PHYSICS_REMOVE_BODY.value: PhysicsPackFormats.PACK_PHYSICS_REMOVE_BODY,
        Events.PHYSICS_APPLY_FORCE.value: PhysicsPackFormats.PACK_PHYSICS_APPLY_FORCE,
        Events.PHYSICS_APPLY_IMPULSE.value: PhysicsPackFormats.PACK_PHYSICS_APPLY_IMPULSE,
        Events.PHYSICS_SET_VELOCITY.value: PhysicsPackFormats.PACK_PHYSICS_SET_VELOCITY,
        Events.PHYSICS_SET_POSITION.value: PhysicsPackFormats.PACK_PHYSICS_SET_POSITION,
        Events.PHYSICS_SET_ROTATION.value: PhysicsPackFormats.PACK_PHYSICS_SET_ROTATION,
        Events.PHYSICS_COLLISION_BEGIN.value: PhysicsPackFormats.UNPACK_PHYSICS_COLLISION,
        Events.PHYSICS_COLLISION_SEPARATE.value: PhysicsPackFormats.UNPACK_PHYSICS_COLLISION,
        Events.PHYSICS_SYNC_TRANSFORM.value: PhysicsPackFormats.UNPACK_PHYSICS_SYNC_TRANSFORM,
        Events.PHYSICS_SET_DEBUG_MODE.value: PhysicsPackFormats.PACK_PHYSICS_SET_DEBUG_MODE,
        Events.PLUGIN.value: PluginPackFormats.PACK_PLUGIN,
        Events.PLUGIN_LOAD.value: PluginPackFormats.PACK_PLUGIN_LOAD,
        Events.PLUGIN_UNLOAD.value: PluginPackFormats.PACK_PLUGIN_UNLOAD,
        Events.PLUGIN_SET.value: PluginPackFormats.PACK_PLUGIN_SET,
        Events.PLUGIN_EVENT_STACKING.value: PluginPackFormats.PACK_PLUGIN_EVENT_STACKING,
        Events.PLUGIN_SUBSCRIBE_EVENT.value: PluginPackFormats.PACK_PLUGIN_SUBSCRIBE_EVENT,
        Events.PLUGIN_UNSUBSCRIBE_EVENT.value: PluginPackFormats.PACK_PLUGIN_UNSUBSCRIBE_EVENT,
        Events.CAMERA_SET_POSITION.value: CameraPackFormats.PACK_CAMERA_SET_POSITION,
        Events.CAMERA_MOVE.value: CameraPackFormats.PACK_CAMERA_MOVE,
        Events.CAMERA_SET_ZOOM.value: CameraPackFormats.PACK_CAMERA_SET_ZOOM,
        Events.CAMERA_SET_ROTATION.value: CameraPackFormats.PACK_CAMERA_SET_ROTATION,
        Events.CAMERA_FOLLOW_ENTITY.value: CameraPackFormats.PACK_CAMERA_FOLLOW_ENTITY,
        Events.CAMERA_STOP_FOLLOWING.value: CameraPackFormats.PACK_CAMERA_STOP_FOLLOWING,
        Events.SCRIPT_SUBSCRIBE.value: ScriptPackFormats.PACK_SCRIPT_SUBSCRIBE,
        Events.SCRIPT_UNSUBSCRIBE.value: ScriptPackFormats.PACK_SCRIPT_UNSUBSCRIBE,
    }

    # This map holds the pre-computed keys for each event
    _EVENT_KEY_MAP: Dict[int, List[str]] = {
        0: ['id1', 'id2', 'positionX', 'positionY', 'positionZ', 'scaleX', 'scaleY', 'scaleZ', 'sizeW', 'sizeH', 'rotationX', 'rotationY', 'rotationZ', 'r', 'g', 'b', 'a', 'speedX', 'speedY'],
        1: ['id1', 'id2'],
        2: ['id1', 'id2', 'positionX', 'positionY', 'positionZ'],
        3: ['id1', 'id2', 'scaleX', 'scaleY', 'scaleZ'],
        4: ['id1', 'id2', 'sizeW', 'sizeH'],
        5: ['id1', 'id2', 'rotationX', 'rotationY', 'rotationZ'],
        6: ['id1', 'id2', 'r', 'g', 'b', 'a'],
        7: ['id1', 'id2', 'speedX', 'speedY'],
        8: ['id1', 'id2', 'filenameLength'],
        9: ['id1', 'id2', 'textureId'],
        10: ['id1', 'id2', 'x', 'y', 'w', 'h'],
        50: ['id1', 'id2', 'z', 'r', 'g', 'b', 'a', 'isScreenSpace', 'x', 'y'],
        51: ['id1', 'id2', 'z', 'r', 'g', 'b', 'a', 'isScreenSpace', 'x1', 'y1', 'x2', 'y2'],
        52: ['id1', 'id2', 'z', 'r', 'g', 'b', 'a', 'isScreenSpace', 'x', 'y', 'w', 'h'],
        53: ['id1', 'id2', 'z', 'r', 'g', 'b', 'a', 'isScreenSpace', 'x', 'y', 'w', 'h'],
        54: ['id1', 'id2', 'z', 'r', 'g', 'b', 'a', 'isScreenSpace', 'primitiveType', 'count'],
        55: ['id1', 'id2'],
        56: ['id1', 'id2', 'r', 'g', 'b', 'a'],
        100: ['scancode', 'keycode', 'mod', 'isRepeat'],
        101: ['scancode', 'keycode', 'mod', 'isRepeat'],
        102: ['x', 'y', 'button', 'clicks'],
        103: ['x', 'y', 'button', 'clicks'],
        104: ['x', 'y', 'xrel', 'yrel'],
        200: ['title'],
        201: ['w', 'h'],
        202: ['flags'],
        300: ['id1', 'id2', 'positionX', 'positionY', 'positionZ', 'r', 'g', 'b', 'a', 'fontSize', 'fontPathLength', 'textLength'],
        301: ['id1', 'id2', 'textLength'],
        400: ['pathLength'],
        401: ['audioId'],
        402: ['audioId'],
        403: ['_unused'],
        404: ['volume'],
        405: ['audioId'],
        406: ['audioId'],
        407: ['audioId'],
        408: ['audioId', 'volume'],
        500: ['id1', 'id2', 'positionX', 'positionY', 'bodyType', 'shapeType', 'lockRotation', 'mass', 'friction', 'elasticity', 'width', 'height'],
        501: ['id1', 'id2'],
        502: ['id1', 'id2', 'forceX', 'forceY'],
        503: ['id1', 'id2', 'impulseX', 'impulseY'],
        504: ['id1', 'id2', 'velocityX', 'velocityY'],
        505: ['id1', 'id2', 'positionX', 'positionY'],
        506: ['id1', 'id2', 'angleInRadians'],
        550: ['id1_A', 'id2_A', 'id1_B', 'id2_B'],
        551: ['id1_A', 'id2_A', 'id1_B', 'id2_B'],
        552: ['id1', 'id2', 'positionX', 'positionY', 'angle', 'velocityX', 'velocityY', 'angularVelocity', 'isSleeping'],
        553: ['enabled'],
        1000: ['eventId'],
        1001: ['channelNo', 'pathLength'],
        1002: ['pluginId'],
        1003: ['pluginId'],
        1004: ['eventId'],
        1005: ['pluginId', 'channelNo'],
        1006: ['pluginId', 'channelNo'],
        2000: ['positionX', 'positionY'],
        2001: ['deltaX', 'deltaY'],
        2002: ['zoom'],
        2003: ['angleInRadians'],
        2004: ['id1', 'id2'],
        2005: ['_unused'],
        3000: ['channelNo'],
        3001: ['channelNo'],
    }


    @staticmethod
    def get_info(event_type_value: int) -> Optional[Tuple[str, int]]:
        """
        Gets the pre-computed (format_string, size) tuple for a given event ID.
        """
        return PackFormat._EVENT_FORMAT_MAP.get(event_type_value)

    @staticmethod
    def unpack(events_blob: bytes) -> List[Dict[str, Any]]:
        """
        Unpacks a binary blob of events (Assumes <I for count/type).
        """
        events = []
        blob_length = len(events_blob)
        if blob_length < 4:
            return []

        try:
            # PHP 'V' = unsigned 32-bit LE -> Python '<I'
            event_count = struct.unpack_from("<I", events_blob, 0)[0]
            offset = 4
        except struct.error:
            print("PackFormat.unpack: Failed to unpack event count.", file=sys.stderr)
            return []

        for i in range(event_count):
            # Header: <I (type) + <Q (timestamp) = 4 + 8 = 12 bytes
            header_size = 12
            if offset + header_size > blob_length:
                print(f"PackFormat.unpack Loop {i}/{event_count}: Not enough data for header. Offset={offset}", file=sys.stderr)
                break

            try:
                header_data = struct.unpack_from("<IQ", events_blob, offset)
                offset += header_size
                event_type, timestamp = header_data
                event = {"type": event_type, "timestamp": timestamp}
            except struct.error:
                print(f"PackFormat.unpack Loop {i}/{event_count}: Failed to unpack header. Offset={offset}", file=sys.stderr)
                break

            try:
                event_enum_val = Events(event_type)
            except ValueError:
                event_enum_val = None

            # --- Manual Unpacking for Variable-Length Events ---
            try:
                if event_type == Events.SPRITE_TEXTURE_LOAD.value:
                    fmt, size = PackFormat.get_info(event_type) # ("<qqI4x", 24)
                    if offset + size > blob_length: raise EOFError("TEXTURE_LOAD fixed part")

                    unpacked = struct.unpack_from(fmt, events_blob, offset)
                    offset += size
                    event["id1"], event["id2"], filename_length = unpacked

                    if offset + filename_length > blob_length: raise EOFError("TEXTURE_LOAD variable part")
                    event["filename"] = events_blob[offset:offset+filename_length].decode('utf-8')
                    offset += filename_length
                    events.append(event)

                elif event_type == Events.PLUGIN_LOAD.value:
                    fmt, size = PackFormat.get_info(event_type) # ("<I", 4)
                    if offset + size > blob_length: raise EOFError("PLUGIN_LOAD fixed part")

                    path_length = struct.unpack_from(fmt, events_blob, offset)[0]
                    offset += size
                    event["pathLength"] = path_length

                    if offset + path_length > blob_length: raise EOFError("PLUGIN_LOAD variable part")
                    event["path"] = events_blob[offset:offset+path_length].decode('utf-8')
                    offset += path_length
                    events.append(event)

                elif event_type == Events.AUDIO_LOAD.value:
                    fmt, size = PackFormat.get_info(event_type) # ("<I", 4)
                    if offset + size > blob_length: raise EOFError("AUDIO_LOAD fixed part")

                    path_length = struct.unpack_from(fmt, events_blob, offset)[0]
                    offset += size
                    event["pathLength"] = path_length

                    if offset + path_length > blob_length: raise EOFError("AUDIO_LOAD variable part")
                    event["path"] = events_blob[offset:offset+path_length].decode('utf-8')
                    offset += path_length
                    events.append(event)

                elif event_type == Events.TEXT_ADD.value:
                    fmt, size = PackFormat.get_info(event_type) # ("<qqdddBBBB4xfII4x", 64)
                    if offset + size > blob_length: raise EOFError("TEXT_ADD fixed part")

                    unpacked = struct.unpack_from(fmt, events_blob, offset)
                    offset += size

                    keys = ["id1", "id2", "positionX", "positionY", "positionZ", "r", "g", "b", "a", "fontSize", "fontPathLength", "textLength"]
                    event.update(zip(keys, unpacked))

                    font_path_len = event["fontPathLength"]
                    text_len = event["textLength"]

                    if offset + font_path_len > blob_length: raise EOFError("TEXT_ADD font path")
                    event["fontPath"] = events_blob[offset:offset+font_path_len].decode('utf-8')
                    offset += font_path_len

                    if offset + text_len > blob_length: raise EOFError("TEXT_ADD text")
                    event["text"] = events_blob[offset:offset+text_len].decode('utf-8')
                    offset += text_len
                    events.append(event)

                elif event_type == Events.TEXT_SET_STRING.value:
                    fmt, size = PackFormat.get_info(event_type) # ("<qqI4x", 24)
                    if offset + size > blob_length: raise EOFError("TEXT_SET_STRING fixed part")

                    unpacked = struct.unpack_from(fmt, events_blob, offset)
                    offset += size

                    keys = ["id1", "id2", "textLength"]
                    event.update(zip(keys, unpacked))

                    text_len = event["textLength"]
                    if offset + text_len > blob_length: raise EOFError("TEXT_SET_STRING text")
                    event["text"] = events_blob[offset:offset+text_len].decode('utf-8')
                    offset += text_len
                    events.append(event)

                elif event_enum_val is not None:
                    # --- Generic Fixed-Size Event Handler ---
                    payload_info = PackFormat.get_info(event_type)
                    if payload_info is None:
                        raise ValueError(f"Could not get info for known event type {event_type}")

                    payload_format, payload_size = payload_info

                    if offset + payload_size > blob_length:
                        raise EOFError(f"{event_enum_val.name} payload (size {payload_size})")

                    if payload_size > 0:
                        unpacked = struct.unpack_from(payload_format, events_blob, offset)

                        # --- MODIFIED BLOCK ---
                        # Use the pre-computed key map instead of generic v{i} keys
                        keys = PackFormat._EVENT_KEY_MAP.get(event_type)

                        if keys is not None:
                            if len(keys) == len(unpacked):
                                payload_data = dict(zip(keys, unpacked))
                            else:
                                # Error: struct definition and key map are out of sync
                                print(f"PackFormat.unpack: Key/Value mismatch for {event_enum_val.name}. Keys: {len(keys)}, Vals: {len(unpacked)}", file=sys.stderr)
                                payload_data = {f"v{i}": val for i, val in enumerate(unpacked)}
                        else:
                            # Fallback for events missing from key map (shouldn't happen)
                            payload_data = {f"v{i}": val for i, val in enumerate(unpacked)}

                        event.update(payload_data)
                        # --- END MODIFIED BLOCK ---

                        events.append(event)
                    else:
                        events.append(event) # No payload

                    offset += payload_size

                else:
                    print(f"PackFormat.unpack: Unknown event type {event_type}. Cannot continue parsing.", file=sys.stderr)
                    break

            except EOFError as e:
                 print(f"PackFormat.unpack: Not enough data for {e}. Stopping parse.", file=sys.stderr)
                 break
            except struct.error as e:
                print(f"PackFormat.unpack: Struct error for {event_enum_val.name if event_enum_val else event_type}: {e}", file=sys.stderr)
                break
            except Exception as e:
                print(f"PackFormat.unpack: General error on {event_enum_val.name if event_enum_val else event_type}: {e}", file=sys.stderr)
                break

        return events# --- End PackFormat Class ---

# --- CommandPacker Class ---
class CommandPacker:

    def __init__(self, chunk_size: int = 0, chunk_callback: Optional[Callable] = None):
        self._event_stream = bytearray()
        self._command_count = 0
        self._event_buffer: List[Dict[str, Any]] = []
        self._chunk_size = chunk_size
        self._chunk_callback = chunk_callback

    def add(self, event_type: Events, data: list):
        """
        Adds a new event to the packer.

        :param event_type: The Events enum member.
        :param data: A list of arguments for the event, matching the
                     struct definition. For dynamic events, the final
                     arguments must be pre-encoded bytes.
        """
        if self._chunk_size > 0:
            self._event_buffer.append({"type": event_type, "data": data})
            if len(self._event_buffer) >= self._chunk_size:
                self._pack_buffered_events()
        else:
            self._pack_event(event_type, data)

    def _pack_event(self, event_type: Events, data: list):
        type_value = event_type.value
        try:
            # Pack header: <I (type) <Q (timestamp) = 12 bytes
            self._event_stream.extend(struct.pack("<IQ", type_value, 0))
        except struct.error as e:
            print(f"CommandPacker ({event_type.name}): Failed to pack header: {e}", file=sys.stderr)
            return

        try:
            # --- Manual Packing for Variable-Length Events ---
            # These events have a (format, size) for their *header*
            # and expect raw bytes as their final argument(s).

            if event_type == Events.SPRITE_TEXTURE_LOAD:
                # data = [id0(q), id1(q), filenameLength(I), filename_bytes(b"")]
                if len(data) != 4: raise ValueError(f"TEXTURE_LOAD: Expected 4 args, got {len(data)}")
                fmt, _ = PackFormat.get_info(type_value) # ("<qqI4x", 24)
                self._event_stream.extend(struct.pack(fmt, data[0], data[1], data[2]))
                self._event_stream.extend(data[3]) # data[3] is already bytes

            elif event_type == Events.PLUGIN_LOAD:
                # data = [pathLength(I), path_bytes(b"")]
                if len(data) != 2: raise ValueError(f"PLUGIN_LOAD: Expected 2 args, got {len(data)}")
                fmt, _ = PackFormat.get_info(type_value) # ("<I", 4)
                self._event_stream.extend(struct.pack(fmt, data[0]))
                self._event_stream.extend(data[1]) # data[1] is already bytes

            elif event_type == Events.AUDIO_LOAD:
                # data = [pathLength(I), path_bytes(b"")]
                if len(data) != 2: raise ValueError(f"AUDIO_LOAD: Expected 2 args, got {len(data)}")
                fmt, _ = PackFormat.get_info(type_value) # ("<I", 4)
                self._event_stream.extend(struct.pack(fmt, data[0]))
                self._event_stream.extend(data[1]) # data[1] is already bytes

            elif event_type == Events.TEXT_ADD:
                # data = [id0(q), id1(q), ..., fontPath_bytes(b""), text_bytes(b"")]
                if len(data) != 14: raise ValueError(f"TEXT_ADD: Expected 14 args, got {len(data)}")
                fmt, _ = PackFormat.get_info(type_value) # ("<qqdddBBBB4xfII4x", 64)
                self._event_stream.extend(struct.pack(
                    fmt,
                    data[0], data[1], data[2], data[3], data[4],  # id, pos
                    data[5], data[6], data[7], data[8],  # rgba
                    data[9], data[10], data[11]  # fontSize, fontPathLen, textLen
                ))
                self._event_stream.extend(data[12]) # fontPath_bytes
                self._event_stream.extend(data[13]) # text_bytes

            elif event_type == Events.TEXT_SET_STRING:
                # data = [id0(q), id1(q), textLength(I), text_bytes(b"")]
                if len(data) != 4: raise ValueError(f"TEXT_SET_STRING: Expected 4 args, got {len(data)}")
                fmt, _ = PackFormat.get_info(type_value) # ("<qqI4x", 24)
                self._event_stream.extend(struct.pack(fmt, data[0], data[1], data[2]))
                self._event_stream.extend(data[3]) # text_bytes

            else:
                # --- Fixed-Size Event Packing Logic ---
                payload_info = PackFormat.get_info(type_value)
                if payload_info is None:
                    raise ValueError(f"Could not get payload info for {event_type.name}")

                fmt, size = payload_info

                if not fmt and data:
                    raise ValueError(f"Format is empty but data was provided for {event_type.name}")

                if fmt:
                    # fmt is the pre-compiled struct string (e.g., "<qqd")
                    self._event_stream.extend(struct.pack(fmt, *data))

            self._command_count += 1

        except (struct.error, ValueError, TypeError) as e:
            print(f"CommandPacker ({event_type.name}): Error during pack! {e}", file=sys.stderr)
            print(f"  Data: {data}", file=sys.stderr)

    def _pack_buffered_events(self):
        if not self._event_buffer:
            return
        for event in self._event_buffer:
            self._pack_event(event["type"], event["data"])

        if self._chunk_callback:
            self._chunk_callback(len(self._event_buffer), self._command_count)

        self._event_buffer = []

    def flush(self):
        if self._event_buffer:
            self._pack_buffered_events()

    def finalize(self) -> bytes:
        self.flush()
        if self._command_count == 0:
            return b""
        # Prepend count (<I) and return the full byte stream
        return struct.pack("<I", self._command_count) + self._event_stream

    def get_buffer_count(self) -> int:
        return len(self._event_buffer)

    def get_total_event_count(self) -> int:
        return self._command_count + len(self._event_buffer)# --- End CommandPacker Class ---

def Id_Generate() -> Tuple[int, int]:
    """Generates a unique ID tuple."""
    return (random.randint(0, 2**63 - 1), random.randint(0, 2**63 - 1))