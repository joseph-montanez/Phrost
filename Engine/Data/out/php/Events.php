<?php

// !!! THIS FILE IS AUTO-GENERATED BY PhpAdapter.php, DO NOT EDIT !!!
// Generated from: structs.json

namespace Phrost;

// --- Events Enum ---
enum Events: int
{
    case SPRITE_ADD = 0;
    case SPRITE_REMOVE = 1;
    case SPRITE_MOVE = 2;
    case SPRITE_SCALE = 3;
    case SPRITE_RESIZE = 4;
    case SPRITE_ROTATE = 5;
    case SPRITE_COLOR = 6;
    case SPRITE_SPEED = 7;
    case SPRITE_TEXTURE_LOAD = 8;
    case SPRITE_TEXTURE_SET = 9;
    case SPRITE_SET_SOURCE_RECT = 10;
    case GEOM_ADD_POINT = 50;
    case GEOM_ADD_LINE = 51;
    case GEOM_ADD_RECT = 52;
    case GEOM_ADD_FILL_RECT = 53;
    case GEOM_ADD_PACKED = 54;
    case GEOM_REMOVE = 55;
    case GEOM_SET_COLOR = 56;

    case INPUT_KEYUP = 100;
    case INPUT_KEYDOWN = 101;
    case INPUT_MOUSEUP = 102;
    case INPUT_MOUSEDOWN = 103;
    case INPUT_MOUSEMOTION = 104;

    case WINDOW_TITLE = 200;
    case WINDOW_RESIZE = 201;
    case WINDOW_FLAGS = 202;

    case TEXT_ADD = 300;
    case TEXT_SET_STRING = 301;

    case AUDIO_LOAD = 400;
    case AUDIO_LOADED = 401;
    case AUDIO_PLAY = 402;
    case AUDIO_STOP_ALL = 403;
    case AUDIO_SET_MASTER_VOLUME = 404;
    case AUDIO_PAUSE = 405;
    case AUDIO_STOP = 406;
    case AUDIO_UNLOAD = 407;
    case AUDIO_SET_VOLUME = 408;

    case PHYSICS_ADD_BODY = 500;
    case PHYSICS_REMOVE_BODY = 501;
    case PHYSICS_APPLY_FORCE = 502;
    case PHYSICS_APPLY_IMPULSE = 503;
    case PHYSICS_SET_VELOCITY = 504;
    case PHYSICS_SET_POSITION = 505;
    case PHYSICS_SET_ROTATION = 506;
    case PHYSICS_COLLISION_BEGIN = 550;
    case PHYSICS_COLLISION_SEPARATE = 551;
    case PHYSICS_SYNC_TRANSFORM = 552;
    case PHYSICS_SET_DEBUG_MODE = 553;

    case PLUGIN = 1000;
    case PLUGIN_LOAD = 1001;
    case PLUGIN_UNLOAD = 1002;
    case PLUGIN_SET = 1003;
    case PLUGIN_EVENT_STACKING = 1004;
    case PLUGIN_SUBSCRIBE_EVENT = 1005;
    case PLUGIN_UNSUBSCRIBE_EVENT = 1006;

    case CAMERA_SET_POSITION = 2000;
    case CAMERA_MOVE = 2001;
    case CAMERA_SET_ZOOM = 2002;
    case CAMERA_SET_ROTATION = 2003;
    case CAMERA_FOLLOW_ENTITY = 2004;
    case CAMERA_STOP_FOLLOWING = 2005;

    case SCRIPT_SUBSCRIBE = 3000;
    case SCRIPT_UNSUBSCRIBE = 3001;
}
// --- End Events Enum ---

// --- Pack Format Classes ---
class SpritePackFormats
{
    /**
     * Maps to Swift: `PackedSpriteAddEvent`
     * - id1: i64 (Primary identifier (e.g., entity ID).)
     * - id2: i64 (Secondary identifier (e.g., component ID).)
     * - positionX: f64 (Initial X position.)
     * - positionY: f64 (Initial Y position.)
     * - positionZ: f64 (Initial Z position (depth).)
     * - scaleX: f64 (Initial X scale.)
     * - scaleY: f64 (Initial Y scale.)
     * - scaleZ: f64 (Initial Z scale.)
     * - sizeW: f64 (Initial width.)
     * - sizeH: f64 (Initial height.)
     * - rotationX: f64 (Initial X rotation (in radians).)
     * - rotationY: f64 (Initial Y rotation (in radians).)
     * - rotationZ: f64 (Initial Z rotation (in radians).)
     * - r: u8 (Red color component (0-255).)
     * - g: u8 (Green color component (0-255).)
     * - b: u8 (Blue color component (0-255).)
     * - a: u8 (Alpha color component (0-255).)
     * - _padding: u32 (Ensures 8-byte alignment for speeds.)
     * - speedX: f64 (Initial X speed.)
     * - speedY: f64 (Initial Y speed.)
     */
    public const PACK_SPRITE_ADD = "qid1/qid2/epositionX/epositionY/epositionZ/escaleX/escaleY/escaleZ/esizeW/esizeH/erotationX/erotationY/erotationZ/Cr/Cg/Cb/Ca/x4_padding/espeedX/espeedY";

    /**
     * Maps to Swift: `PackedSpriteRemoveEvent`
     * - id1: i64 (Primary ID of sprite to remove.)
     * - id2: i64 (Secondary ID of sprite to remove.)
     */
    public const PACK_SPRITE_REMOVE = "qid1/qid2";

    /**
     * Maps to Swift: `PackedSpriteMoveEvent`
     * - id1: i64 (Primary ID of the sprite.)
     * - id2: i64 (Secondary ID of the sprite.)
     * - positionX: f64 (New X position.)
     * - positionY: f64 (New Y position.)
     * - positionZ: f64 (New Z position (depth).)
     */
    public const PACK_SPRITE_MOVE = "qid1/qid2/epositionX/epositionY/epositionZ";

    /**
     * Maps to Swift: `PackedSpriteScaleEvent`
     * - id1: i64 (Primary ID of the sprite.)
     * - id2: i64 (Secondary ID of the sprite.)
     * - scaleX: f64 (New X scale.)
     * - scaleY: f64 (New Y scale.)
     * - scaleZ: f64 (New Z scale.)
     */
    public const PACK_SPRITE_SCALE = "qid1/qid2/escaleX/escaleY/escaleZ";

    /**
     * Maps to Swift: `PackedSpriteResizeEvent`
     * - id1: i64 (Primary ID of the sprite.)
     * - id2: i64 (Secondary ID of the sprite.)
     * - sizeW: f64 (New width.)
     * - sizeH: f64 (New height.)
     */
    public const PACK_SPRITE_RESIZE = "qid1/qid2/esizeW/esizeH";

    /**
     * Maps to Swift: `PackedSpriteRotateEvent`
     * - id1: i64 (Primary ID of the sprite.)
     * - id2: i64 (Secondary ID of the sprite.)
     * - rotationX: f64 (New X rotation (in radians).)
     * - rotationY: f64 (New Y rotation (in radians).)
     * - rotationZ: f64 (New Z rotation (in radians).)
     */
    public const PACK_SPRITE_ROTATE = "qid1/qid2/erotationX/erotationY/erotationZ";

    /**
     * Maps to Swift: `PackedSpriteColorEvent`
     * - id1: i64 (Primary ID of the sprite.)
     * - id2: i64 (Secondary ID of the sprite.)
     * - r: u8 (New red component (0-255).)
     * - g: u8 (New green component (0-255).)
     * - b: u8 (New blue component (0-255).)
     * - a: u8 (New alpha component (0-255).)
     * - _padding: u32 (Padding for alignment.)
     */
    public const PACK_SPRITE_COLOR = "qid1/qid2/Cr/Cg/Cb/Ca/x4_padding";

    /**
     * Maps to Swift: `PackedSpriteSpeedEvent`
     * - id1: i64 (Primary ID of the sprite.)
     * - id2: i64 (Secondary ID of the sprite.)
     * - speedX: f64 (New X speed.)
     * - speedY: f64 (New Y speed.)
     */
    public const PACK_SPRITE_SPEED = "qid1/qid2/espeedX/espeedY";

    /**
     * Maps to Swift: `PackedTextureLoadHeaderEvent`
     * (Header struct)
     * - id1: i64 (ID of the sprite this texture is for.)
     * - id2: i64 (Secondary ID.)
     * - filenameLength: u32 (Length of the texture filename that follows this header.)
     * - _padding: u32 (Padding for alignment.)
     */
    public const PACK_SPRITE_TEXTURE_LOAD = "qid1/qid2/VfilenameLength/x4_padding/a*filename";

    /**
     * Maps to Swift: `PackedSpriteTextureSetEvent`
     * - id1: i64 (Primary ID of the sprite.)
     * - id2: i64 (Secondary ID of the sprite.)
     * - textureId: u64 (The ID of the loaded texture to set.)
     */
    public const PACK_SPRITE_TEXTURE_SET = "qid1/qid2/QtextureId";

    /**
     * Maps to Swift: `PackedSpriteSetSourceRectEvent`
     * - id1: i64 (Primary ID of the sprite.)
     * - id2: i64 (Secondary ID of the sprite.)
     * - x: f32 (Source rect X coordinate.)
     * - y: f32 (Source rect Y coordinate.)
     * - w: f32 (Source rect Width.)
     * - h: f32 (Source rect Height.)
     */
    public const PACK_SPRITE_SET_SOURCE_RECT = "qid1/qid2/gx/gy/gw/gh";

    /**
     * Maps to Swift: `PackedGeomAddPointEvent`
     * - id1: i64 (Primary identifier.)
     * - id2: i64 (Secondary identifier.)
     * - z: f64 (Z position (depth).)
     * - r: u8 (Red color component (0-255).)
     * - g: u8 (Green color component (0-255).)
     * - b: u8 (Blue color component (0-255).)
     * - a: u8 (Alpha color component (0-255).)
     * - isScreenSpace: u8 (If the geometry is unaffected by the camera.)
     * - _padding: u8 (Padding for alignment.)
     * - x: f32 (X coordinate.)
     * - y: f32 (Y coordinate.)
     */
    public const PACK_GEOM_ADD_POINT = "qid1/qid2/ez/Cr/Cg/Cb/Ca/CisScreenSpace/x3_padding/gx/gy";

    /**
     * Maps to Swift: `PackedGeomAddLineEvent`
     * - id1: i64 (Primary identifier.)
     * - id2: i64 (Secondary identifier.)
     * - z: f64 (Z position (depth).)
     * - r: u8 (Red color component (0-255).)
     * - g: u8 (Green color component (0-255).)
     * - b: u8 (Blue color component (0-255).)
     * - a: u8 (Alpha color component (0-255).)
     * - isScreenSpace: u8 (If the geometry is unaffected by the camera.)
     * - _padding: u8 (Padding for alignment.)
     * - x1: f32 (Start X coordinate.)
     * - y1: f32 (Start Y coordinate.)
     * - x2: f32 (End X coordinate.)
     * - y2: f32 (End Y coordinate.)
     */
    public const PACK_GEOM_ADD_LINE = "qid1/qid2/ez/Cr/Cg/Cb/Ca/CisScreenSpace/x3_padding/gx1/gy1/gx2/gy2";

    /**
     * Maps to Swift: `PackedGeomAddRectEvent`
     * - id1: i64 (Primary identifier.)
     * - id2: i64 (Secondary identifier.)
     * - z: f64 (Z position (depth).)
     * - r: u8 (Red color component (0-255).)
     * - g: u8 (Green color component (0-255).)
     * - b: u8 (Blue color component (0-255).)
     * - a: u8 (Alpha color component (0-255).)
     * - isScreenSpace: u8 (If the geometry is unaffected by the camera.)
     * - _padding: u8 (Padding for alignment.)
     * - x: f32 (Top-left X coordinate.)
     * - y: f32 (Top-left Y coordinate.)
     * - w: f32 (Width.)
     * - h: f32 (Height.)
     */
    public const PACK_GEOM_ADD_RECT = "qid1/qid2/ez/Cr/Cg/Cb/Ca/CisScreenSpace/x3_padding/gx/gy/gw/gh";

    /**
     * Maps to Swift: `PackedGeomAddRectEvent`
     * - id1: i64 (Primary identifier.)
     * - id2: i64 (Secondary identifier.)
     * - z: f64 (Z position (depth).)
     * - r: u8 (Red color component (0-255).)
     * - g: u8 (Green color component (0-255).)
     * - b: u8 (Blue color component (0-255).)
     * - a: u8 (Alpha color component (0-255).)
     * - isScreenSpace: u8 (If the geometry is unaffected by the camera.)
     * - _padding: u8 (Padding for alignment.)
     * - x: f32 (Top-left X coordinate.)
     * - y: f32 (Top-left Y coordinate.)
     * - w: f32 (Width.)
     * - h: f32 (Height.)
     */
    public const PACK_GEOM_ADD_FILL_RECT = "qid1/qid2/ez/Cr/Cg/Cb/Ca/CisScreenSpace/x3_padding/gx/gy/gw/gh";

    /**
     * Maps to Swift: `PackedGeomAddPackedHeaderEvent`
     * (Header struct)
     * - id1: i64 (Primary identifier.)
     * - id2: i64 (Secondary identifier.)
     * - z: f64 (Z position (depth).)
     * - r: u8 (Red color component (0-255).)
     * - g: u8 (Green color component (0-255).)
     * - b: u8 (Blue color component (0-255).)
     * - a: u8 (Alpha color component (0-255).)
     * - isScreenSpace: u8 (If the geometry is unaffected by the camera.)
     * - _padding: u16 (Padding for alignment.)
     * - primitiveType: u32 (Raw value from PrimitiveType enum (point, line, rect).)
     * - count: u32 (Number of primitives that follow this header.)
     */
    public const PACK_GEOM_ADD_PACKED = "qid1/qid2/ez/Cr/Cg/Cb/Ca/CisScreenSpace/x2_padding/VprimitiveType/Vcount";

    /**
     * Maps to Swift: `PackedGeomRemoveEvent`
     * - id1: i64 (Primary ID of geometry to remove.)
     * - id2: i64 (Secondary ID of geometry to remove.)
     */
    public const PACK_GEOM_REMOVE = "qid1/qid2";

    /**
     * Maps to Swift: `PackedGeomSetColorEvent`
     * - id1: i64 (Primary ID of the geometry entity.)
     * - id2: i64 (Secondary ID of the geometry entity.)
     * - r: u8 (New red component (0-255).)
     * - g: u8 (New green component (0-255).)
     * - b: u8 (New blue component (0-255).)
     * - a: u8 (New alpha component (0-255).)
     * - _padding: u32 (Padding for alignment.)
     */
    public const PACK_GEOM_SET_COLOR = "qid1/qid2/Cr/Cg/Cb/Ca/x4_padding";
}

class InputPackFormats
{
    /**
     * Maps to Swift: `PackedKeyEvent`
     * - scancode: i32 (Physical key scancode.)
     * - keycode: u32 (Keycode (e.g., Keycode.A).)
     * - mod: u16 (Key modifiers (Shift, Ctrl, etc.).)
     * - isRepeat: u8 (1 if this is a key repeat, 0 otherwise.)
     * - _padding: u8 (Padding for alignment.)
     */
    public const PACK_INPUT_KEYUP = "lscancode/Vkeycode/Smod/CisRepeat/x_padding";

    /**
     * Maps to Swift: `PackedKeyEvent`
     * - scancode: i32 (Physical key scancode.)
     * - keycode: u32 (Keycode (e.g., Keycode.A).)
     * - mod: u16 (Key modifiers (Shift, Ctrl, etc.).)
     * - isRepeat: u8 (1 if this is a key repeat, 0 otherwise.)
     * - _padding: u8 (Padding for alignment.)
     */
    public const PACK_INPUT_KEYDOWN = "lscancode/Vkeycode/Smod/CisRepeat/x_padding";

    /**
     * Maps to Swift: `PackedMouseButtonEvent`
     * - x: f32 (X coordinate of the mouse.)
     * - y: f32 (Y coordinate of the mouse.)
     * - button: u8 (Mouse button index.)
     * - clicks: u8 (Number of clicks (1 for single, 2 for double).)
     * - _padding: u16 (Padding for alignment.)
     */
    public const PACK_INPUT_MOUSEUP = "gx/gy/Cbutton/Cclicks/x2_padding";

    /**
     * Maps to Swift: `PackedMouseButtonEvent`
     * - x: f32 (X coordinate of the mouse.)
     * - y: f32 (Y coordinate of the mouse.)
     * - button: u8 (Mouse button index.)
     * - clicks: u8 (Number of clicks (1 for single, 2 for double).)
     * - _padding: u16 (Padding for alignment.)
     */
    public const PACK_INPUT_MOUSEDOWN = "gx/gy/Cbutton/Cclicks/x2_padding";

    /**
     * Maps to Swift: `PackedMouseMotionEvent`
     * - x: f32 (Absolute X coordinate.)
     * - y: f32 (Absolute Y coordinate.)
     * - xrel: f32 (Relative X motion.)
     * - yrel: f32 (Relative Y motion.)
     */
    public const PACK_INPUT_MOUSEMOTION = "gx/gy/gxrel/gyrel";
}

class WindowPackFormats
{
    /**
     * Maps to Swift: `PackedWindowTitleEvent`
     * - title: char[256] (A fixed-size 256-byte NUL-padded string for the title.)
     */
    public const PACK_WINDOW_TITLE = "a256title";

    /**
     * Maps to Swift: `PackedWindowResizeEvent`
     * - w: i32 (New window width.)
     * - h: i32 (New window height.)
     */
    public const PACK_WINDOW_RESIZE = "lw/lh";

    /**
     * Maps to Swift: `PackedWindowFlagsEvent`
     * - flags: u64 (Bitmask of window flags.)
     */
    public const PACK_WINDOW_FLAGS = "Qflags";
}

class TextPackFormats
{
    /**
     * Maps to Swift: `PackedTextAddEvent`
     * (Header struct)
     * - id1: i64 (Primary identifier.)
     * - id2: i64 (Secondary identifier.)
     * - positionX: f64 (Initial X position.)
     * - positionY: f64 (Initial Y position.)
     * - positionZ: f64 (Initial Z position (depth).)
     * - r: u8 (Red color component (0-255).)
     * - g: u8 (Green color component (0-255).)
     * - b: u8 (Blue color component (0-255).)
     * - a: u8 (Alpha color component (0-255).)
     * - _padding1: u32 (Padding for alignment.)
     * - fontSize: f32 (Font size.)
     * - fontPathLength: u32 (Length of the font path string that follows.)
     * - textLength: u32 (Length of the initial text string that follows.)
     * - _padding2: u32 (Padding.)
     */
    public const PACK_TEXT_ADD = "qid1/qid2/epositionX/epositionY/epositionZ/Cr/Cg/Cb/Ca/x4_padding1/gfontSize/VfontPathLength/VtextLength/x4_padding2/a*fontPath/a*text";

    /**
     * Maps to Swift: `PackedTextSetStringEvent`
     * (Header struct)
     * - id1: i64 (Primary ID of the text entity.)
     * - id2: i64 (Secondary ID of the text entity.)
     * - textLength: u32 (Length of the new text string that follows this header.)
     * - _padding: u32 (Padding for alignment.)
     */
    public const PACK_TEXT_SET_STRING = "qid1/qid2/VtextLength/x4_padding/a*text";
}

class AudioPackFormats
{
    /**
     * Maps to Swift: `PackedAudioLoadEvent`
     * (Header struct)
     * - pathLength: u32 (Length of the audio file path that follows.)
     */
    public const PACK_AUDIO_LOAD = "VpathLength/a*path";

    /**
     * Maps to Swift: `PackedAudioLoadedEvent`
     * - audioId: u64 (The ID assigned to the loaded audio.)
     */
    public const PACK_AUDIO_LOADED = "QaudioId";

    /**
     * Maps to Swift: `PackedAudioPlayEvent`
     * - audioId: u64 (The ID of the audio to play.)
     */
    public const PACK_AUDIO_PLAY = "QaudioId";

    /**
     * Maps to Swift: `PackedAudioStopAllEvent`
     * - _unused: u8 (Padding to ensure non-zero struct size (MSVC compatibility).)
     */
    public const PACK_AUDIO_STOP_ALL = "C_unused";

    /**
     * Maps to Swift: `PackedAudioSetMasterVolumeEvent`
     * - volume: f32 (Volume level (e.g., 0.0 to 1.0).)
     */
    public const PACK_AUDIO_SET_MASTER_VOLUME = "gvolume";

    /**
     * Maps to Swift: `PackedAudioPauseEvent`
     * - audioId: u64 (The ID of the audio to pause.)
     */
    public const PACK_AUDIO_PAUSE = "QaudioId";

    /**
     * Maps to Swift: `PackedAudioStopEvent`
     * - audioId: u64 (The ID of the audio to stop.)
     */
    public const PACK_AUDIO_STOP = "QaudioId";

    /**
     * Maps to Swift: `PackedAudioUnloadEvent`
     * - audioId: u64 (The ID of the audio to unload.)
     */
    public const PACK_AUDIO_UNLOAD = "QaudioId";

    /**
     * Maps to Swift: `PackedAudioSetVolumeEvent`
     * - audioId: u64 (The ID of the audio to modify.)
     * - volume: f32 (Volume level (0.0 to 1.0).)
     * - _padding: u32 (Padding for alignment.)
     */
    public const PACK_AUDIO_SET_VOLUME = "QaudioId/gvolume/x4_padding";
}

class PhysicsPackFormats
{
    /**
     * Maps to Swift: `PackedPhysicsAddBodyEvent`
     * - id1: i64 (Primary identifier.)
     * - id2: i64 (Secondary identifier.)
     * - positionX: f64 (Initial X position.)
     * - positionY: f64 (Initial Y position.)
     * - bodyType: u8 (Body type (static, kinematic, dynamic).)
     * - shapeType: u8 (Shape type (box, circle).)
     * - lockRotation: u8 (Rotation lock (0 = unlocked, 1 = locked). Prevent bodies from falling over.)
     * - _padding: u8 (Padding for 8-byte alignment.)
     * - mass: f64 (Mass of the body.)
     * - friction: f64 (Friction coefficient.)
     * - elasticity: f64 (Elasticity (bounciness).)
     * - width: f64 (Width of the shape (or radius).)
     * - height: f64 (Height of the shape (unused if circle).)
     */
    public const PACK_PHYSICS_ADD_BODY = "qid1/qid2/epositionX/epositionY/CbodyType/CshapeType/ClockRotation/x5_padding/emass/efriction/eelasticity/ewidth/eheight";

    /**
     * Maps to Swift: `PackedPhysicsRemoveBodyEvent`
     * - id1: i64 (Primary ID of body to remove.)
     * - id2: i64 (Secondary ID of body to remove.)
     */
    public const PACK_PHYSICS_REMOVE_BODY = "qid1/qid2";

    /**
     * Maps to Swift: `PackedPhysicsApplyForceEvent`
     * - id1: i64 (Primary ID of the body.)
     * - id2: i64 (Secondary ID of the body.)
     * - forceX: f64 (Force vector X component.)
     * - forceY: f64 (Force vector Y component.)
     */
    public const PACK_PHYSICS_APPLY_FORCE = "qid1/qid2/eforceX/eforceY";

    /**
     * Maps to Swift: `PackedPhysicsApplyImpulseEvent`
     * - id1: i64 (Primary ID of the body.)
     * - id2: i64 (Secondary ID of the body.)
     * - impulseX: f64 (Impulse vector X component.)
     * - impulseY: f64 (Impulse vector Y component.)
     */
    public const PACK_PHYSICS_APPLY_IMPULSE = "qid1/qid2/eimpulseX/eimpulseY";

    /**
     * Maps to Swift: `PackedPhysicsSetVelocityEvent`
     * - id1: i64 (Primary ID of the body.)
     * - id2: i64 (Secondary ID of the body.)
     * - velocityX: f64 (New X velocity.)
     * - velocityY: f64 (New Y velocity.)
     */
    public const PACK_PHYSICS_SET_VELOCITY = "qid1/qid2/evelocityX/evelocityY";

    /**
     * Maps to Swift: `PackedPhysicsSetPositionEvent`
     * - id1: i64 (Primary ID of the body.)
     * - id2: i64 (Secondary ID of the body.)
     * - positionX: f64 (New X position.)
     * - positionY: f64 (New Y position.)
     */
    public const PACK_PHYSICS_SET_POSITION = "qid1/qid2/epositionX/epositionY";

    /**
     * Maps to Swift: `PackedPhysicsSetRotationEvent`
     * - id1: i64 (Primary ID of the body.)
     * - id2: i64 (Secondary ID of the body.)
     * - angleInRadians: f64 (New angle in radians.)
     */
    public const PACK_PHYSICS_SET_ROTATION = "qid1/qid2/eangleInRadians";

    /**
     * Maps to Swift: `PackedPhysicsCollisionEvent`
     * - id1_A: i64 (Primary ID of the first body.)
     * - id2_A: i64 (Secondary ID of the first body.)
     * - id1_B: i64 (Primary ID of the second body.)
     * - id2_B: i64 (Secondary ID of the second body.)
     */
    public const UNPACK_PHYSICS_COLLISION = "qid1_A/qid2_A/qid1_B/qid2_B";

    /**
     * Maps to Swift: `PackedPhysicsSyncTransformEvent`
     * - id1: i64 (Primary ID of the body.)
     * - id2: i64 (Secondary ID of the body.)
     * - positionX: f64 (Current X position.)
     * - positionY: f64 (Current Y position.)
     * - angle: f64 (Current rotation (in radians).)
     * - velocityX: f64 (Current X velocity.)
     * - velocityY: f64 (Current Y velocity.)
     * - angularVelocity: f64 (Current angular velocity (spin speed) in radians/sec.)
     * - isSleeping: u8 (1 if the body is sleeping, 0 if active.)
     * - _padding: u8 (Aligns struct to 64-bit boundary.)
     */
    public const UNPACK_PHYSICS_SYNC_TRANSFORM = "qid1/qid2/epositionX/epositionY/eangle/evelocityX/evelocityY/eangularVelocity/CisSleeping/x7_padding";

    /**
     * Maps to Swift: `PackedPhysicsSetDebugModeEvent`
     * - enabled: u8 (1 to enable debug drawing, 0 to disable.)
     * - _padding: u8 (Padding for 4-byte alignment.)
     */
    public const PACK_PHYSICS_SET_DEBUG_MODE = "Cenabled/x3_padding";
}

class PluginPackFormats
{
    /**
     * Maps to Swift: `PackedPluginOnEvent`
     * - eventId: u8 (A custom event ID for the plugin.)
     */
    public const PACK_PLUGIN = "CeventId";

    /**
     * Maps to Swift: `PackedPluginLoadHeaderEvent`
     * (Header struct)
     * - channelNo: u32 (Initial Channel number to receive events from. Look at channel subscription event to listen to more than one channel.)
     * - pathLength: u32 (Length of the plugin file path that follows.)
     */
    public const PACK_PLUGIN_LOAD = "VchannelNo/VpathLength/a*path";

    /**
     * Maps to Swift: `PackedPluginUnloadEvent`
     * - pluginId: u8 (ID of the plugin to unload.)
     */
    public const PACK_PLUGIN_UNLOAD = "CpluginId";

    /**
     * Maps to Swift: `PackedPluginSetEvent`
     * - pluginId: u8 (ID of the plugin to set as active.)
     */
    public const PACK_PLUGIN_SET = "CpluginId";

    /**
     * Maps to Swift: `PackedPluginEventStackingEvent`
     * - eventId: u8 (1 to enable stacking, 0 to disable.)
     * - _padding: u8 (Padding for alignment.)
     */
    public const PACK_PLUGIN_EVENT_STACKING = "CeventId/x_padding";

    /**
     * Maps to Swift: `PackedPluginSubscribeEvent`
     * - pluginId: u8 (ID of the plugin.)
     * - _padding: u8 (Padding for alignment.)
     * - channelNo: u32 (Channel number to receive events from.)
     */
    public const PACK_PLUGIN_SUBSCRIBE_EVENT = "CpluginId/x3_padding/VchannelNo";

    /**
     * Maps to Swift: `PackedPluginUnsubscribeEvent`
     * - pluginId: u8 (ID of the plugin.)
     * - _padding: u8 (Padding for alignment.)
     * - channelNo: u32 (Channel number to stop receiving events from.)
     */
    public const PACK_PLUGIN_UNSUBSCRIBE_EVENT = "CpluginId/x3_padding/VchannelNo";
}

class CameraPackFormats
{
    /**
     * Maps to Swift: `PackedCameraSetPositionEvent`
     * - positionX: f64 (New X position for the camera's top-left corner.)
     * - positionY: f64 (New Y position for the camera's top-left corner.)
     */
    public const PACK_CAMERA_SET_POSITION = "epositionX/epositionY";

    /**
     * Maps to Swift: `PackedCameraMoveEvent`
     * - deltaX: f64 (Amount to move the camera on the X axis.)
     * - deltaY: f64 (Amount to move the camera on the Y axis.)
     */
    public const PACK_CAMERA_MOVE = "edeltaX/edeltaY";

    /**
     * Maps to Swift: `PackedCameraSetZoomEvent`
     * - zoom: f64 (New zoom level. 1.0 is default, 2.0 is zoomed in.)
     */
    public const PACK_CAMERA_SET_ZOOM = "ezoom";

    /**
     * Maps to Swift: `PackedCameraSetRotationEvent`
     * - angleInRadians: f64 (New camera rotation in radians.)
     */
    public const PACK_CAMERA_SET_ROTATION = "eangleInRadians";

    /**
     * Maps to Swift: `PackedCameraFollowEntityEvent`
     * - id1: i64 (Primary ID of the entity to follow.)
     * - id2: i64 (Secondary ID of the entity to follow.)
     */
    public const PACK_CAMERA_FOLLOW_ENTITY = "qid1/qid2";

    /**
     * Maps to Swift: `PackedCameraStopFollowingEvent`
     * - _unused: u8 (Padding to ensure non-zero struct size (MSVC compatibility).)
     */
    public const PACK_CAMERA_STOP_FOLLOWING = "C_unused";
}

class ScriptPackFormats
{
    /**
     * Maps to Swift: `PackedScriptSubscribeEvent`
     * - channelNo: u32 (Channel number to start receiving events from.)
     * - _padding: u32 (Padding for alignment.)
     */
    public const PACK_SCRIPT_SUBSCRIBE = "VchannelNo/x4_padding";

    /**
     * Maps to Swift: `PackedScriptUnsubscribeEvent`
     * - channelNo: u32 (Channel number to stop receiving events from.)
     * - _padding: u32 (Padding for alignment.)
     */
    public const PACK_SCRIPT_UNSUBSCRIBE = "VchannelNo/x4_padding";
}
// --- End Pack Format Classes ---

// --- PackFormat Class ---
class PackFormat
{
    /** @var array<int, array{format: string, size: int}> */
    private static array $cache = [];

    /** @var array<int, string> */
    private const EVENT_FORMAT_MAP = [
        Events::SPRITE_ADD->value => SpritePackFormats::PACK_SPRITE_ADD,
        Events::SPRITE_REMOVE->value => SpritePackFormats::PACK_SPRITE_REMOVE,
        Events::SPRITE_MOVE->value => SpritePackFormats::PACK_SPRITE_MOVE,
        Events::SPRITE_SCALE->value => SpritePackFormats::PACK_SPRITE_SCALE,
        Events::SPRITE_RESIZE->value => SpritePackFormats::PACK_SPRITE_RESIZE,
        Events::SPRITE_ROTATE->value => SpritePackFormats::PACK_SPRITE_ROTATE,
        Events::SPRITE_COLOR->value => SpritePackFormats::PACK_SPRITE_COLOR,
        Events::SPRITE_SPEED->value => SpritePackFormats::PACK_SPRITE_SPEED,
        Events::SPRITE_TEXTURE_LOAD->value => SpritePackFormats::PACK_SPRITE_TEXTURE_LOAD,
        Events::SPRITE_TEXTURE_SET->value => SpritePackFormats::PACK_SPRITE_TEXTURE_SET,
        Events::SPRITE_SET_SOURCE_RECT->value => SpritePackFormats::PACK_SPRITE_SET_SOURCE_RECT,
        Events::GEOM_ADD_POINT->value => SpritePackFormats::PACK_GEOM_ADD_POINT,
        Events::GEOM_ADD_LINE->value => SpritePackFormats::PACK_GEOM_ADD_LINE,
        Events::GEOM_ADD_RECT->value => SpritePackFormats::PACK_GEOM_ADD_RECT,
        Events::GEOM_ADD_FILL_RECT->value => SpritePackFormats::PACK_GEOM_ADD_FILL_RECT,
        Events::GEOM_ADD_PACKED->value => SpritePackFormats::PACK_GEOM_ADD_PACKED,
        Events::GEOM_REMOVE->value => SpritePackFormats::PACK_GEOM_REMOVE,
        Events::GEOM_SET_COLOR->value => SpritePackFormats::PACK_GEOM_SET_COLOR,
        Events::INPUT_KEYUP->value => InputPackFormats::PACK_INPUT_KEYUP,
        Events::INPUT_KEYDOWN->value => InputPackFormats::PACK_INPUT_KEYDOWN,
        Events::INPUT_MOUSEUP->value => InputPackFormats::PACK_INPUT_MOUSEUP,
        Events::INPUT_MOUSEDOWN->value => InputPackFormats::PACK_INPUT_MOUSEDOWN,
        Events::INPUT_MOUSEMOTION->value => InputPackFormats::PACK_INPUT_MOUSEMOTION,
        Events::WINDOW_TITLE->value => WindowPackFormats::PACK_WINDOW_TITLE,
        Events::WINDOW_RESIZE->value => WindowPackFormats::PACK_WINDOW_RESIZE,
        Events::WINDOW_FLAGS->value => WindowPackFormats::PACK_WINDOW_FLAGS,
        Events::TEXT_ADD->value => TextPackFormats::PACK_TEXT_ADD,
        Events::TEXT_SET_STRING->value => TextPackFormats::PACK_TEXT_SET_STRING,
        Events::AUDIO_LOAD->value => AudioPackFormats::PACK_AUDIO_LOAD,
        Events::AUDIO_LOADED->value => AudioPackFormats::PACK_AUDIO_LOADED,
        Events::AUDIO_PLAY->value => AudioPackFormats::PACK_AUDIO_PLAY,
        Events::AUDIO_STOP_ALL->value => AudioPackFormats::PACK_AUDIO_STOP_ALL,
        Events::AUDIO_SET_MASTER_VOLUME->value => AudioPackFormats::PACK_AUDIO_SET_MASTER_VOLUME,
        Events::AUDIO_PAUSE->value => AudioPackFormats::PACK_AUDIO_PAUSE,
        Events::AUDIO_STOP->value => AudioPackFormats::PACK_AUDIO_STOP,
        Events::AUDIO_UNLOAD->value => AudioPackFormats::PACK_AUDIO_UNLOAD,
        Events::AUDIO_SET_VOLUME->value => AudioPackFormats::PACK_AUDIO_SET_VOLUME,
        Events::PHYSICS_ADD_BODY->value => PhysicsPackFormats::PACK_PHYSICS_ADD_BODY,
        Events::PHYSICS_REMOVE_BODY->value => PhysicsPackFormats::PACK_PHYSICS_REMOVE_BODY,
        Events::PHYSICS_APPLY_FORCE->value => PhysicsPackFormats::PACK_PHYSICS_APPLY_FORCE,
        Events::PHYSICS_APPLY_IMPULSE->value => PhysicsPackFormats::PACK_PHYSICS_APPLY_IMPULSE,
        Events::PHYSICS_SET_VELOCITY->value => PhysicsPackFormats::PACK_PHYSICS_SET_VELOCITY,
        Events::PHYSICS_SET_POSITION->value => PhysicsPackFormats::PACK_PHYSICS_SET_POSITION,
        Events::PHYSICS_SET_ROTATION->value => PhysicsPackFormats::PACK_PHYSICS_SET_ROTATION,
        Events::PHYSICS_COLLISION_BEGIN->value => PhysicsPackFormats::UNPACK_PHYSICS_COLLISION,
        Events::PHYSICS_COLLISION_SEPARATE->value => PhysicsPackFormats::UNPACK_PHYSICS_COLLISION,
        Events::PHYSICS_SYNC_TRANSFORM->value => PhysicsPackFormats::UNPACK_PHYSICS_SYNC_TRANSFORM,
        Events::PHYSICS_SET_DEBUG_MODE->value => PhysicsPackFormats::PACK_PHYSICS_SET_DEBUG_MODE,
        Events::PLUGIN->value => PluginPackFormats::PACK_PLUGIN,
        Events::PLUGIN_LOAD->value => PluginPackFormats::PACK_PLUGIN_LOAD,
        Events::PLUGIN_UNLOAD->value => PluginPackFormats::PACK_PLUGIN_UNLOAD,
        Events::PLUGIN_SET->value => PluginPackFormats::PACK_PLUGIN_SET,
        Events::PLUGIN_EVENT_STACKING->value => PluginPackFormats::PACK_PLUGIN_EVENT_STACKING,
        Events::PLUGIN_SUBSCRIBE_EVENT->value => PluginPackFormats::PACK_PLUGIN_SUBSCRIBE_EVENT,
        Events::PLUGIN_UNSUBSCRIBE_EVENT->value => PluginPackFormats::PACK_PLUGIN_UNSUBSCRIBE_EVENT,
        Events::CAMERA_SET_POSITION->value => CameraPackFormats::PACK_CAMERA_SET_POSITION,
        Events::CAMERA_MOVE->value => CameraPackFormats::PACK_CAMERA_MOVE,
        Events::CAMERA_SET_ZOOM->value => CameraPackFormats::PACK_CAMERA_SET_ZOOM,
        Events::CAMERA_SET_ROTATION->value => CameraPackFormats::PACK_CAMERA_SET_ROTATION,
        Events::CAMERA_FOLLOW_ENTITY->value => CameraPackFormats::PACK_CAMERA_FOLLOW_ENTITY,
        Events::CAMERA_STOP_FOLLOWING->value => CameraPackFormats::PACK_CAMERA_STOP_FOLLOWING,
        Events::SCRIPT_SUBSCRIBE->value => ScriptPackFormats::PACK_SCRIPT_SUBSCRIBE,
        Events::SCRIPT_UNSUBSCRIBE->value => ScriptPackFormats::PACK_SCRIPT_UNSUBSCRIBE,
    ];

    /**
     * Gets descriptive format and calculates size based on summing format codes.
     * For variable formats ('*'), size is only for the fixed part. Includes padding codes (x).
     */
    public static function getInfo(int $eventTypeValue): ?array
    {
        if (isset(self::$cache[$eventTypeValue])) {
            return self::$cache[$eventTypeValue];
        }

        $descriptiveFormat = self::EVENT_FORMAT_MAP[$eventTypeValue] ?? null;
        if ($descriptiveFormat === null) {
            return null;
        }

        // --- Reverted Size Calculation Logic ---
        static $sizeMap = [
            "a" => 1, "A" => 1, "Z" => 1, "h" => 0.5, "H" => 0.5, "c" => 1,
            "C" => 1, "s" => 2, "S" => 2, "n" => 2, "v" => 2, "l" => 4,
            "L" => 4, "N" => 4, "V" => 4, "i" => 4, "I" => 4, "f" => 4,
            "g" => 4, "G" => 4, "q" => 8, "Q" => 8, "J" => 8, "P" => 8,
            "d" => 8, "e" => 8, "E" => 8, "x" => 1, "X" => -1, "@" => 0,
        ];

        $totalSize = 0;
        foreach (explode("/", $descriptiveFormat) as $part) {
            // Match format code (letter) and optional repeater (* or digits)
            if (preg_match("/^([a-zA-Z])(\*|\d*)/", $part, $matches)) {
                // Use ^ to match start
                $code = $matches[1];
                $repeater = $matches[2];

                if ($repeater === "*") {
                    // It's a variable length part, stop calculating size here
                    // Check against a list of known dynamic events
                    static $dynamicEvents = [
                        Events::SPRITE_TEXTURE_LOAD->value,
                        Events::PLUGIN_LOAD->value,
                        Events::TEXT_ADD->value,
                        Events::TEXT_SET_STRING->value,
                        Events::AUDIO_LOAD->value,
                        Events::GEOM_ADD_PACKED->value
                    ];

                    if (in_array($eventTypeValue, $dynamicEvents)) {
                        break;
                    } else {
                        error_log(
                            "PackFormat::getInfo: Unexpected '*' in format '{$descriptiveFormat}' for event {$eventTypeValue}. Size calculation might be wrong."
                        );
                        break; // Stop calculation
                    }
                }

                $count = $repeater === "" || !ctype_digit($repeater)
                            ? 1
                            : (int) $repeater;
                $size = $sizeMap[$code] ?? 0;
                if ($size === 0 && $code !== "@") {
                    error_log(
                        "PackFormat::getInfo: Unknown format code '{$code}' in format '{$descriptiveFormat}' for event {$eventTypeValue}."
                    );
                }

                if ($code === "h" || $code === "H") {
                    $totalSize += ceil($count * $size);
                } else {
                    $totalSize += $count * $size;
                }
            } else {
                if (!empty(trim($part))) {
                    error_log(
                        "PackFormat::getInfo: Could not parse format part '{$part}' in format '{$descriptiveFormat}' for event {$eventTypeValue}."
                    );
                }
            }
        }

        $result = ["format" => $descriptiveFormat, "size" => (int) $totalSize];
        self::$cache[$eventTypeValue] = $result;
        return $result;
    }

    /**
     * Unpacks a binary blob of events (Assumes V for count/type).
     * NOTE: Primarily for PHP-side use/testing; Swift handles its own unpacking.
     */
    public static function unpack(string $eventsBlob): array
    {
        $events = [];
        $blobLength = strlen($eventsBlob);
        if ($blobLength < 4) {
            return [];
        }

        $countUnpack = unpack("Vcount", $eventsBlob);
        if ($countUnpack === false) {
            error_log("PackFormat::unpack: Failed to unpack event count.");
            return [];
        }
        $eventCount = $countUnpack["count"];
        $offset = 4;

        for ($i = 0; $i < $eventCount; $i++) {
            $headerSize = 4 + 8; // type (V) + timestamp (Q) = 12 bytes
            if ($offset + $headerSize > $blobLength) {
                error_log("PackFormat::unpack Loop {$i}/{$eventCount}: Not enough data for header. Offset={$offset}");
                break;
            }

            $headerData = unpack("Vtype/Qtimestamp", substr($eventsBlob, $offset, $headerSize));
            if ($headerData === false) {
                error_log("PackFormat::unpack Loop {$i}/{$eventCount}: Failed to unpack header. Offset={$offset}");
                break;
            }
            $offset += $headerSize;
            $eventType = $headerData["type"];
            $eventEnumValue = Events::tryFrom($eventType);

            if ($eventType === Events::SPRITE_TEXTURE_LOAD->value) {
                $fixedPartSize = 24; // q(8) + q(8) + V(4) + x4(4)
                if ($offset + $fixedPartSize > $blobLength) { error_log("PackFormat::unpack (TEXTURE_LOAD): Not enough data for fixed part."); break; }
                $fixedPartData = unpack("qid1/qid2/VfilenameLength/x4padding", substr($eventsBlob, $offset, $fixedPartSize));
                if ($fixedPartData === false) { error_log("PackFormat::unpack (TEXTURE_LOAD): Failed to unpack fixed part."); break; }
                $offset += $fixedPartSize;
                $filenameLength = $fixedPartData["filenameLength"];
                if ($offset + $filenameLength > $blobLength) { error_log("PackFormat::unpack (TEXTURE_LOAD): Not enough data for variable part."); break; }
                $stringPartData = ($filenameLength > 0) ? unpack("a{$filenameLength}filename", substr($eventsBlob, $offset, $filenameLength)) : ["filename" => ""];
                $offset += $filenameLength;
                $events[] = $headerData + $fixedPartData + $stringPartData;

            } elseif ($eventType === Events::PLUGIN_LOAD->value) {
                $fixedPartSize = 4; // V(4)
                if ($offset + $fixedPartSize > $blobLength) { error_log("PackFormat::unpack (PLUGIN_LOAD): Not enough data for fixed part."); break; }
                $fixedPartData = unpack("VpathLength", substr($eventsBlob, $offset, $fixedPartSize));
                if ($fixedPartData === false) { error_log("PackFormat::unpack (PLUGIN_LOAD): Failed to unpack fixed part."); break; }
                $offset += $fixedPartSize;
                $pathLength = $fixedPartData["pathLength"];
                if ($offset + $pathLength > $blobLength) { error_log("PackFormat::unpack (PLUGIN_LOAD): Not enough data for variable part."); break; }
                $stringPartData = ($pathLength > 0) ? unpack("a{$pathLength}path", substr($eventsBlob, $offset, $pathLength)) : ["path" => ""];
                $offset += $pathLength;
                $events[] = $headerData + $fixedPartData + $stringPartData;

            } elseif ($eventType === Events::AUDIO_LOAD->value) {
                 $fixedPartSize = 4; // V(4)
                if ($offset + $fixedPartSize > $blobLength) { error_log("PackFormat::unpack (AUDIO_LOAD): Not enough data for fixed part."); break; }
                $fixedPartData = unpack("VpathLength", substr($eventsBlob, $offset, $fixedPartSize));
                if ($fixedPartData === false) { error_log("PackFormat::unpack (AUDIO_LOAD): Failed to unpack fixed part."); break; }
                $offset += $fixedPartSize;
                $pathLength = $fixedPartData["pathLength"];
                if ($offset + $pathLength > $blobLength) { error_log("PackFormat::unpack (AUDIO_LOAD): Not enough data for variable part."); break; }
                $stringPartData = ($pathLength > 0) ? unpack("a{$pathLength}path", substr($eventsBlob, $offset, $pathLength)) : ["path" => ""];
                $offset += $pathLength;
                $events[] = $headerData + $fixedPartData + $stringPartData;

            } elseif ($eventType === Events::TEXT_ADD->value) {
                // Manually check format: qid1/qid2/epositionX/epositionY/epositionZ/Cr/Cg/Cb/Ca/x4/gfontSize/VfontPathLength/VtextLength/x4
                $fixedPartSize = 8+8+8+8+8+1+1+1+1+4+4+4+4+4; // 64 bytes
                if ($offset + $fixedPartSize > $blobLength) { error_log("PackFormat::unpack (TEXT_ADD): Not enough data for fixed part."); break; }
                $fixedPartData = unpack(
                    "qid1/qid2/epositionX/epositionY/epositionZ/Cr/Cg/Cb/Ca/x4padding1/gfontSize/VfontPathLength/VtextLength/x4padding2",
                    substr($eventsBlob, $offset, $fixedPartSize)
                );
                if ($fixedPartData === false) { error_log("PackFormat::unpack (TEXT_ADD): Failed to unpack fixed part."); break; }
                $offset += $fixedPartSize;
                $fontPathLength = $fixedPartData["fontPathLength"];
                $textLength = $fixedPartData["textLength"];

                if ($offset + $fontPathLength > $blobLength) { error_log("PackFormat::unpack (TEXT_ADD): Not enough data for font path."); break; }
                $fontPathData = ($fontPathLength > 0) ? unpack("a{$fontPathLength}fontPath", substr($eventsBlob, $offset, $fontPathLength)) : ["fontPath" => ""];
                $offset += $fontPathLength;

                if ($offset + $textLength > $blobLength) { error_log("PackFormat::unpack (TEXT_ADD): Not enough data for text."); break; }
                $textData = ($textLength > 0) ? unpack("a{$textLength}text", substr($eventsBlob, $offset, $textLength)) : ["text" => ""];
                $offset += $textLength;
                $events[] = $headerData + $fixedPartData + $fontPathData + $textData;

            } elseif ($eventType === Events::TEXT_SET_STRING->value) {
                $fixedPartSize = 24; // q(8) + q(8) + V(4) + x4(4)
                if ($offset + $fixedPartSize > $blobLength) { error_log("PackFormat::unpack (TEXT_SET_STRING): Not enough data for fixed part."); break; }
                $fixedPartData = unpack("qid1/qid2/VtextLength/x4padding", substr($eventsBlob, $offset, $fixedPartSize));
                if ($fixedPartData === false) { error_log("PackFormat::unpack (TEXT_SET_STRING): Failed to unpack fixed part."); break; }
                $offset += $fixedPartSize;
                $textLength = $fixedPartData["textLength"];

                if ($offset + $textLength > $blobLength) { error_log("PackFormat::unpack (TEXT_SET_STRING): Not enough data for text."); break; }
                $textData = ($textLength > 0) ? unpack("a{$textLength}text", substr($eventsBlob, $offset, $textLength)) : ["text" => ""];
                $offset += $textLength;
                $events[] = $headerData + $fixedPartData + $textData;

            } elseif ($eventEnumValue !== null) {
                // Handle other known fixed-size events
                $payloadInfo = self::getInfo($eventType);
                if ($payloadInfo === null) {
                    error_log("PackFormat::unpack: Could not get info for known event type {$eventType}.");
                    break;
                }

                $payloadSize = $payloadInfo["size"];
                $payloadFormat = $payloadInfo["format"];

                if ($offset + $payloadSize > $blobLength) {
                    error_log("PackFormat::unpack ({$eventEnumValue->name}): Not enough data for payload (size {$payloadSize}).");
                    break;
                }

                if ($payloadSize > 0) {
                    $payloadData = unpack($payloadFormat, substr($eventsBlob, $offset, $payloadSize));
                    if ($payloadData === false) {
                        error_log("PackFormat::unpack ({$eventEnumValue->name}): Failed to unpack payload.");
                        break;
                    }
                    $payloadData = array_filter($payloadData, "is_string", ARRAY_FILTER_USE_KEY);
                    $events[] = $headerData + $payloadData;
                } else {
                    $events[] = $headerData; // Event with no payload
                }
                $offset += $payloadSize;
            } else {
                error_log("PackFormat::unpack: Unknown event type {$eventType}. Cannot continue parsing.");
                error_log(bin2hex($eventsBlob));
                break;
            }
        }
        return $events;
    }}
// --- End PackFormat Class ---

// --- CommandPacker Class ---
class CommandPacker
{
    private string $eventStream = "";
    private int $commandCount = 0;
    private static array $pureFormatCache = [];
    private array $eventBuffer = [];
    private int $chunkSize = 0;
    private $chunkCallback = null;

    public function __construct(int $chunkSize = 0, $chunkCallback = null)
    {
        $this->chunkSize = $chunkSize;
        $this->chunkCallback = $chunkCallback;
    }

    public function add(Events $type, array $data): void
    {
        if ($this->chunkSize > 0) {
            $this->eventBuffer[] = ["type" => $type, "data" => $data];
            if (count($this->eventBuffer) >= $this->chunkSize) {
                $this->packBufferedEvents();
            }
        } else {
            $this->packEvent($type, $data);
        }
    }

    private function packEvent(Events $type, array $data): void
    {
        $typeValue = $type->value;
        $this->eventStream .= pack("VQ", $typeValue, 0); // 12 bytes header (type + timestamp)

        if ($type === Events::SPRITE_TEXTURE_LOAD) {
            if (count($data) !== 4) { error_log("CommandPacker (TEXTURE_LOAD): Incorrect data count, expected 4."); return; }
            $packedFixedPart = pack("qqVx4", $data[0], $data[1], $data[2]);
            $this->eventStream .= $packedFixedPart;
            $this->eventStream .= $data[3]; // Append filename string

        } elseif ($type === Events::PLUGIN_LOAD) {
             if (count($data) !== 2) { error_log("CommandPacker (PLUGIN_LOAD): Incorrect data count, expected 2."); return; }
            $packedFixedPart = pack("V", $data[0]);
            $this->eventStream .= $packedFixedPart;
            $this->eventStream .= $data[1]; // Append path string

        } elseif ($type === Events::AUDIO_LOAD) {
             if (count($data) !== 2) { error_log("CommandPacker (AUDIO_LOAD): Incorrect data count, expected 2."); return; }
            $packedFixedPart = pack("V", $data[0]);
            $this->eventStream .= $packedFixedPart;
            $this->eventStream .= $data[1]; // Append path string

        } elseif ($type === Events::TEXT_ADD) {
             if (count($data) !== 14) { error_log("CommandPacker (TEXT_ADD): Incorrect data count, expected 14."); return; }
             // Corrected format: e = f64, g = f32
            $packedFixedPart = pack("qqeeeCCCCx4gVVx4",
                $data[0], $data[1], $data[2], $data[3], $data[4], // id1, id2, posXYZ (e)
                $data[5], $data[6], $data[7], $data[8],             // rgba (C)
                $data[9], $data[10], $data[11]                      // fontSize(g), fontPathLength(V), textLength(V)
            );
            $this->eventStream .= $packedFixedPart;
            $this->eventStream .= $data[12]; // Append fontPath
            $this->eventStream .= $data[13]; // Append text

        } elseif ($type === Events::TEXT_SET_STRING) {
             if (count($data) !== 4) { error_log("CommandPacker (TEXT_SET_STRING): Incorrect data count, expected 4."); return; }
            $packedFixedPart = pack("qqVx4", $data[0], $data[1], $data[2]);
            $this->eventStream .= $packedFixedPart;
            $this->eventStream .= $data[3]; // Append text string

        } else {
            // --- Fixed-Size Event Packing Logic ---
            $payloadInfo = PackFormat::getInfo($typeValue);
            if ($payloadInfo === null) { error_log("CommandPacker ({$type->name}): Could not get payload info."); return; }

            $pureFormat = self::getPureFormat($payloadInfo["format"]);
            if (empty($pureFormat) && !empty($data)) { error_log("CommandPacker ({$type->name}): Format is empty but data was provided."); return; }

            if (empty($pureFormat) && empty($data)) {
                 // Correctly handle no-payload events like AUDIO_STOP_ALL
            } else {
                $numericData = array_values($data);
                try {
                    $packedPayload = pack($pureFormat, ...$numericData);
                    if ($packedPayload === false) {
                        error_log("CommandPacker ({$type->name}): pack() returned false. Format='{$pureFormat}'");
                    } else {
                        $this->eventStream .= $packedPayload;
                    }
                } catch (\ValueError $e) {
                    error_log("CommandPacker ({$type->name}): ValueError during pack()! Format='{$pureFormat}', Error: {$e->getMessage()}");
                } catch (\Exception $e) {
                    error_log("CommandPacker ({$type->name}): Exception during pack()! Format='{$pureFormat}', Error: {$e->getMessage()}");
                }
            }
        }
        $this->commandCount++;
    }

    private function packBufferedEvents(): void
    {
        if (empty($this->eventBuffer)) { return; }
        foreach ($this->eventBuffer as $event) {
            $this->packEvent($event["type"], $event["data"]);
        }
        if ($this->chunkCallback !== null) {
            ($this->chunkCallback)(count($this->eventBuffer), $this->commandCount);
        }
        $this->eventBuffer = [];
    }

    public function flush(): void
    {
        if (!empty($this->eventBuffer)) {
            $this->packBufferedEvents();
        }
    }

    public function finalize(): string
    {
        $this->flush();
        if ($this->commandCount === 0) {
            return "";
        }
        return pack("V", $this->commandCount) . $this->eventStream;
    }

    public function getBufferCount(): int
    {
        return count($this->eventBuffer);
    }

    public function getTotalEventCount(): int
    {
        return $this->commandCount + count($this->eventBuffer);
    }

    private static function getPureFormat(string $descriptiveFormat): string
    {
        if (isset(self::$pureFormatCache[$descriptiveFormat])) {
            return self::$pureFormatCache[$descriptiveFormat];
        }
        $pure = "";
        foreach (explode("/", $descriptiveFormat) as $part) {
            if (preg_match("/^([a-zA-Z])(\*|\d*)/", $part, $matches)) {
                $code = $matches[1];
                $count = $matches[2];
                if ($count === '*') {
                    break; // Stop at variable part
                }
                $pure .= $code . $count;
            }
        }
        return self::$pureFormatCache[$descriptiveFormat] = $pure;
    }
}// --- End CommandPacker Class ---
