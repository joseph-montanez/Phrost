// !!! THIS FILE IS AUTO-GENERATED BY RustAdapter.php, DO NOT EDIT !!!
// Generated from: structs.json

// Add `byteorder = "1.0"` to your Cargo.toml dependencies

#![allow(dead_code)]
#![allow(non_camel_case_types)]

use std::io::{Cursor, Read, Seek, SeekFrom, Write};
use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};

// --- Events Enum ---
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum Events {
    spriteAdd = 0,
    spriteRemove = 1,
    spriteMove = 2,
    spriteScale = 3,
    spriteResize = 4,
    spriteRotate = 5,
    spriteColor = 6,
    spriteSpeed = 7,
    spriteTextureLoad = 8,
    spriteTextureSet = 9,
    spriteSetSourceRect = 10,
    geomAddPoint = 50,
    geomAddLine = 51,
    geomAddRect = 52,
    geomAddFillRect = 53,
    geomAddPacked = 54,
    geomRemove = 55,
    geomSetColor = 56,

    inputKeyup = 100,
    inputKeydown = 101,
    inputMouseup = 102,
    inputMousedown = 103,
    inputMousemotion = 104,

    windowTitle = 200,
    windowResize = 201,
    windowFlags = 202,

    textAdd = 300,
    textSetString = 301,

    audioLoad = 400,
    audioLoaded = 401,
    audioPlay = 402,
    audioStopAll = 403,
    audioSetMasterVolume = 404,
    audioPause = 405,
    audioStop = 406,
    audioUnload = 407,
    audioSetVolume = 408,

    physicsAddBody = 500,
    physicsRemoveBody = 501,
    physicsApplyForce = 502,
    physicsApplyImpulse = 503,
    physicsSetVelocity = 504,
    physicsSetPosition = 505,
    physicsSetRotation = 506,
    physicsCollisionBegin = 550,
    physicsCollisionSeparate = 551,
    physicsSyncTransform = 552,
    physicsSetDebugMode = 553,

    plugin = 1000,
    pluginLoad = 1001,
    pluginUnload = 1002,
    pluginSet = 1003,
    pluginEventStacking = 1004,
    pluginSubscribeEvent = 1005,
    pluginUnsubscribeEvent = 1006,

    cameraSetPosition = 2000,
    cameraMove = 2001,
    cameraSetZoom = 2002,
    cameraSetRotation = 2003,
    cameraFollowEntity = 2004,
    cameraStopFollowing = 2005,

    scriptSubscribe = 3000,
    scriptUnsubscribe = 3001,
}

impl Events {
    pub fn from_u32(value: u32) -> Option<Self> {
        match value {
            0 => Some(Events::spriteAdd),
            1 => Some(Events::spriteRemove),
            2 => Some(Events::spriteMove),
            3 => Some(Events::spriteScale),
            4 => Some(Events::spriteResize),
            5 => Some(Events::spriteRotate),
            6 => Some(Events::spriteColor),
            7 => Some(Events::spriteSpeed),
            8 => Some(Events::spriteTextureLoad),
            9 => Some(Events::spriteTextureSet),
            10 => Some(Events::spriteSetSourceRect),
            50 => Some(Events::geomAddPoint),
            51 => Some(Events::geomAddLine),
            52 => Some(Events::geomAddRect),
            53 => Some(Events::geomAddFillRect),
            54 => Some(Events::geomAddPacked),
            55 => Some(Events::geomRemove),
            56 => Some(Events::geomSetColor),
            100 => Some(Events::inputKeyup),
            101 => Some(Events::inputKeydown),
            102 => Some(Events::inputMouseup),
            103 => Some(Events::inputMousedown),
            104 => Some(Events::inputMousemotion),
            200 => Some(Events::windowTitle),
            201 => Some(Events::windowResize),
            202 => Some(Events::windowFlags),
            300 => Some(Events::textAdd),
            301 => Some(Events::textSetString),
            400 => Some(Events::audioLoad),
            401 => Some(Events::audioLoaded),
            402 => Some(Events::audioPlay),
            403 => Some(Events::audioStopAll),
            404 => Some(Events::audioSetMasterVolume),
            405 => Some(Events::audioPause),
            406 => Some(Events::audioStop),
            407 => Some(Events::audioUnload),
            408 => Some(Events::audioSetVolume),
            500 => Some(Events::physicsAddBody),
            501 => Some(Events::physicsRemoveBody),
            502 => Some(Events::physicsApplyForce),
            503 => Some(Events::physicsApplyImpulse),
            504 => Some(Events::physicsSetVelocity),
            505 => Some(Events::physicsSetPosition),
            506 => Some(Events::physicsSetRotation),
            550 => Some(Events::physicsCollisionBegin),
            551 => Some(Events::physicsCollisionSeparate),
            552 => Some(Events::physicsSyncTransform),
            553 => Some(Events::physicsSetDebugMode),
            1000 => Some(Events::plugin),
            1001 => Some(Events::pluginLoad),
            1002 => Some(Events::pluginUnload),
            1003 => Some(Events::pluginSet),
            1004 => Some(Events::pluginEventStacking),
            1005 => Some(Events::pluginSubscribeEvent),
            1006 => Some(Events::pluginUnsubscribeEvent),
            2000 => Some(Events::cameraSetPosition),
            2001 => Some(Events::cameraMove),
            2002 => Some(Events::cameraSetZoom),
            2003 => Some(Events::cameraSetRotation),
            2004 => Some(Events::cameraFollowEntity),
            2005 => Some(Events::cameraStopFollowing),
            3000 => Some(Events::scriptSubscribe),
            3001 => Some(Events::scriptUnsubscribe),
            _ => None,
        }
    }
}

// --- Packed Struct Definitions ---

/// Header for loading an audio file. Variable data (path string) follows.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedAudioLoadEvent {
    pub path_length: u32, // Length of the audio file path that follows.
}

/// Payload sent *from* engine *to* client when audio is loaded.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedAudioLoadedEvent {
    pub audio_id: u64, // The ID assigned to the loaded audio.
}

/// Payload to pause a specific, playing audio sound.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedAudioPauseEvent {
    pub audio_id: u64, // The ID of the audio to pause.
}

/// Payload to play a loaded audio file.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedAudioPlayEvent {
    pub audio_id: u64, // The ID of the audio to play.
}

/// Payload to set the global master volume.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedAudioSetMasterVolumeEvent {
    pub volume: f32, // Volume level (e.g., 0.0 to 1.0).
}

/// Payload to set the volume of a specific audio sound.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedAudioSetVolumeEvent {
    pub audio_id: u64, // The ID of the audio to modify.
    pub volume: f32, // Volume level (0.0 to 1.0).
    pub _padding: u32, // Padding for alignment.
}

/// Stops all playing audio. This event has no payload.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedAudioStopAllEvent {
    pub _unused: u8, // Padding to ensure non-zero struct size (MSVC compatibility).
}

/// Payload to stop and rewind a specific audio sound.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedAudioStopEvent {
    pub audio_id: u64, // The ID of the audio to stop.
}

/// Payload to unload a specific audio sound, freeing memory.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedAudioUnloadEvent {
    pub audio_id: u64, // The ID of the audio to unload.
}

/// Tells the camera to start following a specific entity.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedCameraFollowEntityEvent {
    pub id1: i64, // Primary ID of the entity to follow.
    pub id2: i64, // Secondary ID of the entity to follow.
}

/// Payload to move the 2D camera by a relative delta.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedCameraMoveEvent {
    pub delta_x: f64, // Amount to move the camera on the X axis.
    pub delta_y: f64, // Amount to move the camera on the Y axis.
}

/// Payload to set the 2D camera's absolute world position.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedCameraSetPositionEvent {
    pub position_x: f64, // New X position for the camera's top-left corner.
    pub position_y: f64, // New Y position for the camera's top-left corner.
}

/// Payload to set the 2D camera's rotation.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedCameraSetRotationEvent {
    pub angle_in_radians: f64, // New camera rotation in radians.
}

/// Payload to set the 2D camera's zoom level.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedCameraSetZoomEvent {
    pub zoom: f64, // New zoom level. 1.0 is default, 2.0 is zoomed in.
}

/// Tells the camera to stop following any entity.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedCameraStopFollowingEvent {
    pub _unused: u8, // Padding to ensure non-zero struct size (MSVC compatibility).
}

/// Payload for adding a single geometry line.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedGeomAddLineEvent {
    pub id1: i64, // Primary identifier.
    pub id2: i64, // Secondary identifier.
    pub z: f64, // Z position (depth).
    pub r: u8, // Red color component (0-255).
    pub g: u8, // Green color component (0-255).
    pub b: u8, // Blue color component (0-255).
    pub a: u8, // Alpha color component (0-255).
    pub is_screen_space: u8, // If the geometry is unaffected by the camera.
    pub _padding: [u8; 3], // Padding for alignment.
    pub x1: f32, // Start X coordinate.
    pub y1: f32, // Start Y coordinate.
    pub x2: f32, // End X coordinate.
    pub y2: f32, // End Y coordinate.
}

/// Header for adding a batch of geometry primitives. Variable data (array of points/rects) follows.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedGeomAddPackedHeaderEvent {
    pub id1: i64, // Primary identifier.
    pub id2: i64, // Secondary identifier.
    pub z: f64, // Z position (depth).
    pub r: u8, // Red color component (0-255).
    pub g: u8, // Green color component (0-255).
    pub b: u8, // Blue color component (0-255).
    pub a: u8, // Alpha color component (0-255).
    pub is_screen_space: u8, // If the geometry is unaffected by the camera.
    pub _padding: u16, // Padding for alignment.
    pub primitive_type: u32, // Raw value from PrimitiveType enum (point, line, rect).
    pub count: u32, // Number of primitives that follow this header.
}

/// Payload for adding a single geometry point.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedGeomAddPointEvent {
    pub id1: i64, // Primary identifier.
    pub id2: i64, // Secondary identifier.
    pub z: f64, // Z position (depth).
    pub r: u8, // Red color component (0-255).
    pub g: u8, // Green color component (0-255).
    pub b: u8, // Blue color component (0-255).
    pub a: u8, // Alpha color component (0-255).
    pub is_screen_space: u8, // If the geometry is unaffected by the camera.
    pub _padding: [u8; 3], // Padding for alignment.
    pub x: f32, // X coordinate.
    pub y: f32, // Y coordinate.
}

/// Payload for adding a geometry rectangle (outline).
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedGeomAddRectEvent {
    pub id1: i64, // Primary identifier.
    pub id2: i64, // Secondary identifier.
    pub z: f64, // Z position (depth).
    pub r: u8, // Red color component (0-255).
    pub g: u8, // Green color component (0-255).
    pub b: u8, // Blue color component (0-255).
    pub a: u8, // Alpha color component (0-255).
    pub is_screen_space: u8, // If the geometry is unaffected by the camera.
    pub _padding: [u8; 3], // Padding for alignment.
    pub x: f32, // Top-left X coordinate.
    pub y: f32, // Top-left Y coordinate.
    pub w: f32, // Width.
    pub h: f32, // Height.
}

/// Payload for removing a geometry entity.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedGeomRemoveEvent {
    pub id1: i64, // Primary ID of geometry to remove.
    pub id2: i64, // Secondary ID of geometry to remove.
}

/// Payload to set a geometry entity's color.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedGeomSetColorEvent {
    pub id1: i64, // Primary ID of the geometry entity.
    pub id2: i64, // Secondary ID of the geometry entity.
    pub r: u8, // New red component (0-255).
    pub g: u8, // New green component (0-255).
    pub b: u8, // New blue component (0-255).
    pub a: u8, // New alpha component (0-255).
    pub _padding: u32, // Padding for alignment.
}

/// Payload for a key release event.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedKeyEvent {
    pub scancode: i32, // Physical key scancode.
    pub keycode: u32, // Keycode (e.g., Keycode.A).
    pub r#mod: u16, // Key modifiers (Shift, Ctrl, etc.).
    pub is_repeat: u8, // 1 if this is a key repeat, 0 otherwise.
    pub _padding: u8, // Padding for alignment.
}

/// Payload for a mouse button release event.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedMouseButtonEvent {
    pub x: f32, // X coordinate of the mouse.
    pub y: f32, // Y coordinate of the mouse.
    pub button: u8, // Mouse button index.
    pub clicks: u8, // Number of clicks (1 for single, 2 for double).
    pub _padding: u16, // Padding for alignment.
}

/// Payload for a mouse motion event.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedMouseMotionEvent {
    pub x: f32, // Absolute X coordinate.
    pub y: f32, // Absolute Y coordinate.
    pub xrel: f32, // Relative X motion.
    pub yrel: f32, // Relative Y motion.
}

/// Payload for adding a new physics body to the world.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedPhysicsAddBodyEvent {
    pub id1: i64, // Primary identifier.
    pub id2: i64, // Secondary identifier.
    pub position_x: f64, // Initial X position.
    pub position_y: f64, // Initial Y position.
    pub body_type: u8, // Body type (static, kinematic, dynamic).
    pub shape_type: u8, // Shape type (box, circle).
    pub lock_rotation: u8, // Rotation lock (0 = unlocked, 1 = locked). Prevent bodies from falling over.
    pub _padding: [u8; 5], // Padding for 8-byte alignment.
    pub mass: f64, // Mass of the body.
    pub friction: f64, // Friction coefficient.
    pub elasticity: f64, // Elasticity (bounciness).
    pub width: f64, // Width of the shape (or radius).
    pub height: f64, // Height of the shape (unused if circle).
}

/// Payload to apply a continuous force to a body.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedPhysicsApplyForceEvent {
    pub id1: i64, // Primary ID of the body.
    pub id2: i64, // Secondary ID of the body.
    pub force_x: f64, // Force vector X component.
    pub force_y: f64, // Force vector Y component.
}

/// Payload to apply an instant impulse to a body.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedPhysicsApplyImpulseEvent {
    pub id1: i64, // Primary ID of the body.
    pub id2: i64, // Secondary ID of the body.
    pub impulse_x: f64, // Impulse vector X component.
    pub impulse_y: f64, // Impulse vector Y component.
}

/// Payload sent *from* engine when two bodies begin colliding.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedPhysicsCollisionEvent {
    pub id1_a: i64, // Primary ID of the first body.
    pub id2_a: i64, // Secondary ID of the first body.
    pub id1_b: i64, // Primary ID of the second body.
    pub id2_b: i64, // Secondary ID of the second body.
}

/// Payload for removing a physics body.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedPhysicsRemoveBodyEvent {
    pub id1: i64, // Primary ID of body to remove.
    pub id2: i64, // Secondary ID of body to remove.
}

/// Payload to toggle physics debug rendering.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedPhysicsSetDebugModeEvent {
    pub enabled: u8, // 1 to enable debug drawing, 0 to disable.
    pub _padding: [u8; 3], // Padding for 4-byte alignment.
}

/// Payload to teleport a body to a new position.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedPhysicsSetPositionEvent {
    pub id1: i64, // Primary ID of the body.
    pub id2: i64, // Secondary ID of the body.
    pub position_x: f64, // New X position.
    pub position_y: f64, // New Y position.
}

/// Payload to set a body's rotation.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedPhysicsSetRotationEvent {
    pub id1: i64, // Primary ID of the body.
    pub id2: i64, // Secondary ID of the body.
    pub angle_in_radians: f64, // New angle in radians.
}

/// Payload to set a body's linear velocity.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedPhysicsSetVelocityEvent {
    pub id1: i64, // Primary ID of the body.
    pub id2: i64, // Secondary ID of the body.
    pub velocity_x: f64, // New X velocity.
    pub velocity_y: f64, // New Y velocity.
}

/// Payload sent *from* engine to sync 2D physics state back to client.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedPhysicsSyncTransformEvent {
    pub id1: i64, // Primary ID of the body.
    pub id2: i64, // Secondary ID of the body.
    pub position_x: f64, // Current X position.
    pub position_y: f64, // Current Y position.
    pub angle: f64, // Current rotation (in radians).
    pub velocity_x: f64, // Current X velocity.
    pub velocity_y: f64, // Current Y velocity.
    pub angular_velocity: f64, // Current angular velocity (spin speed) in radians/sec.
    pub is_sleeping: u8, // 1 if the body is sleeping, 0 if active.
    pub _padding: [u8; 7], // Aligns struct to 64-bit boundary.
}

/// Payload to enable or disable plugin event stacking.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedPluginEventStackingEvent {
    pub event_id: u8, // 1 to enable stacking, 0 to disable.
    pub _padding: u8, // Padding for alignment.
}

/// Header for loading a plugin. Variable data (path string) follows.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedPluginLoadHeaderEvent {
    pub channel_no: u32, // Initial Channel number to receive events from. Look at channel subscription event to listen to more than one channel.
    pub path_length: u32, // Length of the plugin file path that follows.
}

/// Payload for a generic plugin 'on' event.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedPluginOnEvent {
    pub event_id: u8, // A custom event ID for the plugin.
}

/// Payload to set the active plugin.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedPluginSetEvent {
    pub plugin_id: u8, // ID of the plugin to set as active.
}

/// Have events from a channel forward to this plugin
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedPluginSubscribeEvent {
    pub plugin_id: u8, // ID of the plugin.
    pub _padding: [u8; 3], // Padding for alignment.
    pub channel_no: u32, // Channel number to receive events from.
}

/// Payload to unload a plugin.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedPluginUnloadEvent {
    pub plugin_id: u8, // ID of the plugin to unload.
}

/// Have events from a channel forward to this plugin
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedPluginUnsubscribeEvent {
    pub plugin_id: u8, // ID of the plugin.
    pub _padding: [u8; 3], // Padding for alignment.
    pub channel_no: u32, // Channel number to stop receiving events from.
}

/// Tells the engine to subscribe the main script (PHP) to a channel.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedScriptSubscribeEvent {
    pub channel_no: u32, // Channel number to start receiving events from.
    pub _padding: u32, // Padding for alignment.
}

/// Tells the engine to unsubscribe the main script (PHP) from a channel.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedScriptUnsubscribeEvent {
    pub channel_no: u32, // Channel number to stop receiving events from.
    pub _padding: u32, // Padding for alignment.
}

/// Payload for adding a new sprite to the scene.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedSpriteAddEvent {
    pub id1: i64, // Primary identifier (e.g., entity ID).
    pub id2: i64, // Secondary identifier (e.g., component ID).
    pub position_x: f64, // Initial X position.
    pub position_y: f64, // Initial Y position.
    pub position_z: f64, // Initial Z position (depth).
    pub scale_x: f64, // Initial X scale.
    pub scale_y: f64, // Initial Y scale.
    pub scale_z: f64, // Initial Z scale.
    pub size_w: f64, // Initial width.
    pub size_h: f64, // Initial height.
    pub rotation_x: f64, // Initial X rotation (in radians).
    pub rotation_y: f64, // Initial Y rotation (in radians).
    pub rotation_z: f64, // Initial Z rotation (in radians).
    pub r: u8, // Red color component (0-255).
    pub g: u8, // Green color component (0-255).
    pub b: u8, // Blue color component (0-255).
    pub a: u8, // Alpha color component (0-255).
    pub _padding: u32, // Ensures 8-byte alignment for speeds.
    pub speed_x: f64, // Initial X speed.
    pub speed_y: f64, // Initial Y speed.
}

/// Payload to set a sprite's color modulation.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedSpriteColorEvent {
    pub id1: i64, // Primary ID of the sprite.
    pub id2: i64, // Secondary ID of the sprite.
    pub r: u8, // New red component (0-255).
    pub g: u8, // New green component (0-255).
    pub b: u8, // New blue component (0-255).
    pub a: u8, // New alpha component (0-255).
    pub _padding: u32, // Padding for alignment.
}

/// Payload to move a sprite to an absolute position.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedSpriteMoveEvent {
    pub id1: i64, // Primary ID of the sprite.
    pub id2: i64, // Secondary ID of the sprite.
    pub position_x: f64, // New X position.
    pub position_y: f64, // New Y position.
    pub position_z: f64, // New Z position (depth).
}

/// Payload for removing a sprite from the scene.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedSpriteRemoveEvent {
    pub id1: i64, // Primary ID of sprite to remove.
    pub id2: i64, // Secondary ID of sprite to remove.
}

/// Payload to set a sprite's size (width/height).
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedSpriteResizeEvent {
    pub id1: i64, // Primary ID of the sprite.
    pub id2: i64, // Secondary ID of the sprite.
    pub size_w: f64, // New width.
    pub size_h: f64, // New height.
}

/// Payload to set a sprite's rotation.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedSpriteRotateEvent {
    pub id1: i64, // Primary ID of the sprite.
    pub id2: i64, // Secondary ID of the sprite.
    pub rotation_x: f64, // New X rotation (in radians).
    pub rotation_y: f64, // New Y rotation (in radians).
    pub rotation_z: f64, // New Z rotation (in radians).
}

/// Payload to set a sprite's scale.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedSpriteScaleEvent {
    pub id1: i64, // Primary ID of the sprite.
    pub id2: i64, // Secondary ID of the sprite.
    pub scale_x: f64, // New X scale.
    pub scale_y: f64, // New Y scale.
    pub scale_z: f64, // New Z scale.
}

/// Sets the source rectangle (spritesheet clipping) for a sprite.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedSpriteSetSourceRectEvent {
    pub id1: i64, // Primary ID of the sprite.
    pub id2: i64, // Secondary ID of the sprite.
    pub x: f32, // Source rect X coordinate.
    pub y: f32, // Source rect Y coordinate.
    pub w: f32, // Source rect Width.
    pub h: f32, // Source rect Height.
}

/// Payload to set a sprite's speed.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedSpriteSpeedEvent {
    pub id1: i64, // Primary ID of the sprite.
    pub id2: i64, // Secondary ID of the sprite.
    pub speed_x: f64, // New X speed.
    pub speed_y: f64, // New Y speed.
}

/// Payload to set a sprite's texture to an already loaded one.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedSpriteTextureSetEvent {
    pub id1: i64, // Primary ID of the sprite.
    pub id2: i64, // Secondary ID of the sprite.
    pub texture_id: u64, // The ID of the loaded texture to set.
}

/// Header for adding new text. Variable data (font path, text string) follows.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedTextAddEvent {
    pub id1: i64, // Primary identifier.
    pub id2: i64, // Secondary identifier.
    pub position_x: f64, // Initial X position.
    pub position_y: f64, // Initial Y position.
    pub position_z: f64, // Initial Z position (depth).
    pub r: u8, // Red color component (0-255).
    pub g: u8, // Green color component (0-255).
    pub b: u8, // Blue color component (0-255).
    pub a: u8, // Alpha color component (0-255).
    pub _padding1: u32, // Padding for alignment.
    pub font_size: f32, // Font size.
    pub font_path_length: u32, // Length of the font path string that follows.
    pub text_length: u32, // Length of the initial text string that follows.
    pub _padding2: u32, // Padding.
}

/// Header for setting a text entity's string. Variable data (text string) follows.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedTextSetStringEvent {
    pub id1: i64, // Primary ID of the text entity.
    pub id2: i64, // Secondary ID of the text entity.
    pub text_length: u32, // Length of the new text string that follows this header.
    pub _padding: u32, // Padding for alignment.
}

/// Header for loading a texture. Variable data (filename string) follows.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedTextureLoadHeaderEvent {
    pub id1: i64, // ID of the sprite this texture is for.
    pub id2: i64, // Secondary ID.
    pub filename_length: u32, // Length of the texture filename that follows this header.
    pub _padding: u32, // Padding for alignment.
}

/// Payload for setting window flags (e.g., fullscreen, borderless).
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedWindowFlagsEvent {
    pub flags: u64, // Bitmask of window flags.
}

/// Payload for a window resize event.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedWindowResizeEvent {
    pub w: i32, // New window width.
    pub h: i32, // New window height.
}

/// Payload for setting the window title.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PackedWindowTitleEvent {
    pub title: [u8; 256], // A fixed-size 256-byte NUL-padded string for the title.
}

// --- Command Packer ---

pub struct CommandPacker {
    buffer: Vec<u8>,
    command_count: u32,
}

impl CommandPacker {
    pub fn new() -> Self {
        Self { buffer: Vec::new(), command_count: 0 }
    }

    /// Finalizes the buffer by prepending the command count.
    pub fn finalize(self) -> Vec<u8> {
        let mut final_buffer = Vec::with_capacity(4 + self.buffer.len());
        final_buffer.write_u32::<LittleEndian>(self.command_count).unwrap();
        final_buffer.extend(self.buffer);
        final_buffer
    }

    pub fn command_count(&self) -> u32 {
        self.command_count
    }

    /// Writes the event type and a 0 timestamp.
    fn write_header(&mut self, event_type: Events) -> std::io::Result<()> {
        self.buffer.write_u32::<LittleEndian>(event_type as u32)?;
        self.buffer.write_u64::<LittleEndian>(0)?; // 8-byte timestamp
        Ok(())
    }

    /// Packs a fixed-size payload.
    pub fn pack<T: Copy>(&mut self, event_type: Events, payload: &T) -> std::io::Result<()> {
        self.write_header(event_type)?;
        let bytes: &[u8] = unsafe {
            // SAFETY: Assumes T is #[repr(C, packed)] and valid for any byte pattern.
            std::slice::from_raw_parts(
                (payload as *const T) as *const u8,
                std::mem::size_of::<T>(),
            )
        };
        self.buffer.write_all(bytes)?;
        self.command_count += 1;
        Ok(())
    }

    pub fn pack_sprite_texture_load(&mut self, id1: i64, id2: i64, filename: &[u8]) -> std::io::Result<()> {
        self.write_header(Events::spriteTextureLoad)?;
        let header = PackedTextureLoadHeaderEvent {
            id1: id1,
            id2: id2,
            filename_length: filename.len() as u32,
            _padding: 0
        };
        let header_bytes: &[u8] = unsafe {
            std::slice::from_raw_parts(
                (&header as *const PackedTextureLoadHeaderEvent) as *const u8,
                std::mem::size_of::<PackedTextureLoadHeaderEvent>(),
            )
        };
        self.buffer.write_all(header_bytes)?;
        self.buffer.write_all(filename)?;
        self.command_count += 1;
        Ok(())
    }

    pub fn pack_geom_add_packed(&mut self, id1: i64, id2: i64, z: f64, r: u8, g: u8, b: u8, a: u8, is_screen_space: u8) -> std::io::Result<()> {
        self.write_header(Events::geomAddPacked)?;
        let header = PackedGeomAddPackedHeaderEvent {
            id1: id1,
            id2: id2,
            z: z,
            r: r,
            g: g,
            b: b,
            a: a,
            is_screen_space: is_screen_space,
            _padding: 0,
            primitive_type: 0,
            count: 0
        };
        let header_bytes: &[u8] = unsafe {
            std::slice::from_raw_parts(
                (&header as *const PackedGeomAddPackedHeaderEvent) as *const u8,
                std::mem::size_of::<PackedGeomAddPackedHeaderEvent>(),
            )
        };
        self.buffer.write_all(header_bytes)?;
        self.command_count += 1;
        Ok(())
    }

    pub fn pack_text_add(&mut self, id1: i64, id2: i64, position_x: f64, position_y: f64, position_z: f64, r: u8, g: u8, b: u8, a: u8, font_size: f32, font_path: &[u8], text: &[u8]) -> std::io::Result<()> {
        self.write_header(Events::textAdd)?;
        let header = PackedTextAddEvent {
            id1: id1,
            id2: id2,
            position_x: position_x,
            position_y: position_y,
            position_z: position_z,
            r: r,
            g: g,
            b: b,
            a: a,
            _padding1: 0,
            font_size: font_size,
            font_path_length: font_path.len() as u32,
            text_length: text.len() as u32,
            _padding2: 0
        };
        let header_bytes: &[u8] = unsafe {
            std::slice::from_raw_parts(
                (&header as *const PackedTextAddEvent) as *const u8,
                std::mem::size_of::<PackedTextAddEvent>(),
            )
        };
        self.buffer.write_all(header_bytes)?;
        self.buffer.write_all(font_path)?;
        self.buffer.write_all(text)?;
        self.command_count += 1;
        Ok(())
    }

    pub fn pack_text_set_string(&mut self, id1: i64, id2: i64, text: &[u8]) -> std::io::Result<()> {
        self.write_header(Events::textSetString)?;
        let header = PackedTextSetStringEvent {
            id1: id1,
            id2: id2,
            text_length: text.len() as u32,
            _padding: 0
        };
        let header_bytes: &[u8] = unsafe {
            std::slice::from_raw_parts(
                (&header as *const PackedTextSetStringEvent) as *const u8,
                std::mem::size_of::<PackedTextSetStringEvent>(),
            )
        };
        self.buffer.write_all(header_bytes)?;
        self.buffer.write_all(text)?;
        self.command_count += 1;
        Ok(())
    }

    pub fn pack_audio_load(&mut self, path: &[u8]) -> std::io::Result<()> {
        self.write_header(Events::audioLoad)?;
        let header = PackedAudioLoadEvent {
            path_length: path.len() as u32
        };
        let header_bytes: &[u8] = unsafe {
            std::slice::from_raw_parts(
                (&header as *const PackedAudioLoadEvent) as *const u8,
                std::mem::size_of::<PackedAudioLoadEvent>(),
            )
        };
        self.buffer.write_all(header_bytes)?;
        self.buffer.write_all(path)?;
        self.command_count += 1;
        Ok(())
    }

    pub fn pack_plugin_load(&mut self, path: &[u8]) -> std::io::Result<()> {
        self.write_header(Events::pluginLoad)?;
        let header = PackedPluginLoadHeaderEvent {
            channel_no: 0,
            path_length: path.len() as u32
        };
        let header_bytes: &[u8] = unsafe {
            std::slice::from_raw_parts(
                (&header as *const PackedPluginLoadHeaderEvent) as *const u8,
                std::mem::size_of::<PackedPluginLoadHeaderEvent>(),
            )
        };
        self.buffer.write_all(header_bytes)?;
        self.buffer.write_all(path)?;
        self.command_count += 1;
        Ok(())
    }

}

// --- Event Unpacker ---

pub struct EventUnpacker<'a> {
    cursor: Cursor<&'a [u8]>,}

impl<'a> EventUnpacker<'a> {
    pub fn new(blob: &'a [u8]) -> Self {
        Self { cursor: Cursor::new(blob) }
    }

    /// Reads the total event count from the start of the blob.
    pub fn read_count(&mut self) -> std::io::Result<u32> {
        self.cursor.read_u32::<LittleEndian>()
    }

    /// Reads the event type (u32) and timestamp (u64).
    pub fn read_event_header(&mut self) -> std::io::Result<(Events, u64)> {
        let event_type_id = self.cursor.read_u32::<LittleEndian>()?;
        let timestamp = self.cursor.read_u64::<LittleEndian>()?;
        let event_type = Events::from_u32(event_type_id).ok_or_else(||
            std::io::Error::new(std::io::ErrorKind::InvalidData, "Unknown event type ID")
        )?;
        Ok((event_type, timestamp))
    }

    /// Reads a fixed-size payload struct.
    pub fn read_payload<T: Copy>(&mut self) -> std::io::Result<T> {
        // Create a zeroed instance of T.
        let mut payload: T = unsafe { std::mem::zeroed() };
        // Create a mutable byte slice that points to the payload.
        let buffer: &mut [u8] = unsafe {
            std::slice::from_raw_parts_mut(
                (&mut payload as *mut T) as *mut u8,
                std::mem::size_of::<T>(),
            )
        };
        // Read directly from the cursor into the payload's byte slice.
        self.cursor.read_exact(buffer)?;
        Ok(payload)
    }

    /// Reads a variable-length byte vector.
    pub fn read_variable(&mut self, len: u32) -> std::io::Result<Vec<u8>> {
        let mut buffer = vec![0u8; len as usize];
        self.cursor.read_exact(&mut buffer)?;
        Ok(buffer)
    }

    /// Skips N bytes in the stream.
    pub fn skip(&mut self, n: u32) -> std::io::Result<()> {
        self.cursor.seek(SeekFrom::Current(n as i64))?;
        Ok(())
    }

    pub fn position(&self) -> u64 {
        self.cursor.position()
    }
}
