// !!! THIS FILE IS AUTO-GENERATED BY ZigAdapter.php, DO NOT EDIT !!!
// Generated from: structs.json

const std = @import("std");
pub const Channels = enum(u32) {
    renderer = 0,
    input = 1,
    physics = 2,
    audio = 3,
    gui = 4,
    window = 5,
    script = 6,
};

pub const Events = enum(u32) {
    spriteAdd = 0,
    spriteRemove = 1,
    spriteMove = 2,
    spriteScale = 3,
    spriteResize = 4,
    spriteRotate = 5,
    spriteColor = 6,
    spriteSpeed = 7,
    spriteTextureLoad = 8,
    spriteTextureSet = 9,
    spriteSetSourceRect = 10,
    geomAddPoint = 50,
    geomAddLine = 51,
    geomAddRect = 52,
    geomAddFillRect = 53,
    geomAddPacked = 54,
    geomRemove = 55,
    geomSetColor = 56,

    inputKeyup = 100,
    inputKeydown = 101,
    inputMouseup = 102,
    inputMousedown = 103,
    inputMousemotion = 104,

    windowTitle = 200,
    windowResize = 201,
    windowFlags = 202,

    textAdd = 300,
    textSetString = 301,

    audioLoad = 400,
    audioLoaded = 401,
    audioPlay = 402,
    audioStopAll = 403,
    audioSetMasterVolume = 404,
    audioPause = 405,
    audioStop = 406,
    audioUnload = 407,
    audioSetVolume = 408,

    physicsAddBody = 500,
    physicsRemoveBody = 501,
    physicsApplyForce = 502,
    physicsApplyImpulse = 503,
    physicsSetVelocity = 504,
    physicsSetPosition = 505,
    physicsSetRotation = 506,
    physicsCollisionBegin = 550,
    physicsCollisionSeparate = 551,
    physicsSyncTransform = 552,
    physicsSetDebugMode = 553,

    plugin = 1000,
    pluginLoad = 1001,
    pluginUnload = 1002,
    pluginSet = 1003,
    pluginEventStacking = 1004,
    pluginSubscribeEvent = 1005,
    pluginUnsubscribeEvent = 1006,

    cameraSetPosition = 2000,
    cameraMove = 2001,
    cameraSetZoom = 2002,
    cameraSetRotation = 2003,
    cameraFollowEntity = 2004,
    cameraStopFollowing = 2005,

    scriptSubscribe = 3000,
    scriptUnsubscribe = 3001,
};

pub const PackedAudioLoadEvent = extern struct {
    pathLength: u32,
};

pub const PackedAudioLoadedEvent = extern struct {
    audioId: u64,
};

pub const PackedAudioPauseEvent = extern struct {
    audioId: u64,
};

pub const PackedAudioPlayEvent = extern struct {
    audioId: u64,
};

pub const PackedAudioSetMasterVolumeEvent = extern struct {
    volume: f32,
};

pub const PackedAudioSetVolumeEvent = extern struct {
    audioId: u64,
    volume: f32,
    _padding: u32,
};

pub const PackedAudioStopAllEvent = extern struct {
    _unused: u8,
};

pub const PackedAudioStopEvent = extern struct {
    audioId: u64,
};

pub const PackedAudioUnloadEvent = extern struct {
    audioId: u64,
};

pub const PackedCameraFollowEntityEvent = extern struct {
    id1: i64,
    id2: i64,
};

pub const PackedCameraMoveEvent = extern struct {
    deltaX: f64,
    deltaY: f64,
};

pub const PackedCameraSetPositionEvent = extern struct {
    positionX: f64,
    positionY: f64,
};

pub const PackedCameraSetRotationEvent = extern struct {
    angleInRadians: f64,
};

pub const PackedCameraSetZoomEvent = extern struct {
    zoom: f64,
};

pub const PackedCameraStopFollowingEvent = extern struct {
    _unused: u8,
};

pub const PackedGeomAddLineEvent = extern struct {
    id1: i64,
    id2: i64,
    z: f64,
    r: u8,
    g: u8,
    b: u8,
    a: u8,
    isScreenSpace: u8,
    _padding: [3]u8,
    x1: f32,
    y1: f32,
    x2: f32,
    y2: f32,
};

pub const PackedGeomAddPackedHeaderEvent = extern struct {
    id1: i64,
    id2: i64,
    z: f64,
    r: u8,
    g: u8,
    b: u8,
    a: u8,
    isScreenSpace: u8,
    _padding: u16,
    primitiveType: u32,
    count: u32,
};

pub const PackedGeomAddPointEvent = extern struct {
    id1: i64,
    id2: i64,
    z: f64,
    r: u8,
    g: u8,
    b: u8,
    a: u8,
    isScreenSpace: u8,
    _padding: [3]u8,
    x: f32,
    y: f32,
};

pub const PackedGeomAddRectEvent = extern struct {
    id1: i64,
    id2: i64,
    z: f64,
    r: u8,
    g: u8,
    b: u8,
    a: u8,
    isScreenSpace: u8,
    _padding: [3]u8,
    x: f32,
    y: f32,
    w: f32,
    h: f32,
};

pub const PackedGeomRemoveEvent = extern struct {
    id1: i64,
    id2: i64,
};

pub const PackedGeomSetColorEvent = extern struct {
    id1: i64,
    id2: i64,
    r: u8,
    g: u8,
    b: u8,
    a: u8,
    _padding: u32,
};

pub const PackedKeyEvent = extern struct {
    scancode: i32,
    keycode: u32,
    mod: u16,
    isRepeat: u8,
    _padding: u8,
};

pub const PackedMouseButtonEvent = extern struct {
    x: f32,
    y: f32,
    button: u8,
    clicks: u8,
    _padding: u16,
};

pub const PackedMouseMotionEvent = extern struct {
    x: f32,
    y: f32,
    xrel: f32,
    yrel: f32,
};

pub const PackedPhysicsAddBodyEvent = extern struct {
    id1: i64,
    id2: i64,
    positionX: f64,
    positionY: f64,
    bodyType: u8,
    shapeType: u8,
    lockRotation: u8,
    _padding: [5]u8,
    mass: f64,
    friction: f64,
    elasticity: f64,
    width: f64,
    height: f64,
};

pub const PackedPhysicsApplyForceEvent = extern struct {
    id1: i64,
    id2: i64,
    forceX: f64,
    forceY: f64,
};

pub const PackedPhysicsApplyImpulseEvent = extern struct {
    id1: i64,
    id2: i64,
    impulseX: f64,
    impulseY: f64,
};

pub const PackedPhysicsCollisionEvent = extern struct {
    id1_A: i64,
    id2_A: i64,
    id1_B: i64,
    id2_B: i64,
};

pub const PackedPhysicsRemoveBodyEvent = extern struct {
    id1: i64,
    id2: i64,
};

pub const PackedPhysicsSetDebugModeEvent = extern struct {
    enabled: u8, // 1 to enable debug drawing, 0 to disable.
    _padding: [3]u8, // Padding for 4-byte alignment.
};

pub const PackedPhysicsSetPositionEvent = extern struct {
    id1: i64,
    id2: i64,
    positionX: f64,
    positionY: f64,
};

pub const PackedPhysicsSetRotationEvent = extern struct {
    id1: i64,
    id2: i64,
    angleInRadians: f64,
};

pub const PackedPhysicsSetVelocityEvent = extern struct {
    id1: i64,
    id2: i64,
    velocityX: f64,
    velocityY: f64,
};

pub const PackedPhysicsSyncTransformEvent = extern struct {
    id1: i64,
    id2: i64,
    positionX: f64,
    positionY: f64,
    angle: f64,
    velocityX: f64,
    velocityY: f64,
    angularVelocity: f64,
    isSleeping: u8,
    _padding: [7]u8,
};

pub const PackedPluginEventStackingEvent = extern struct {
    eventId: u8,
    _padding: u8,
};

pub const PackedPluginLoadHeaderEvent = extern struct {
    channelNo: u32,
    pathLength: u32,
};

pub const PackedPluginOnEvent = extern struct {
    eventId: u8,
};

pub const PackedPluginSetEvent = extern struct {
    pluginId: u8,
};

pub const PackedPluginSubscribeEvent = extern struct {
    pluginId: u8,
    _padding: [3]u8,
    channelNo: u32,
};

pub const PackedPluginUnloadEvent = extern struct {
    pluginId: u8,
};

pub const PackedPluginUnsubscribeEvent = extern struct {
    pluginId: u8,
    _padding: [3]u8,
    channelNo: u32,
};

pub const PackedScriptSubscribeEvent = extern struct {
    channelNo: u32,
    _padding: u32,
};

pub const PackedScriptUnsubscribeEvent = extern struct {
    channelNo: u32,
    _padding: u32,
};

pub const PackedSpriteAddEvent = extern struct {
    id1: i64,
    id2: i64,
    positionX: f64,
    positionY: f64,
    positionZ: f64,
    scaleX: f64,
    scaleY: f64,
    scaleZ: f64,
    sizeW: f64,
    sizeH: f64,
    rotationX: f64,
    rotationY: f64,
    rotationZ: f64,
    r: u8,
    g: u8,
    b: u8,
    a: u8,
    _padding: u32,
    speedX: f64,
    speedY: f64,
};

pub const PackedSpriteColorEvent = extern struct {
    id1: i64,
    id2: i64,
    r: u8,
    g: u8,
    b: u8,
    a: u8,
    _padding: u32,
};

pub const PackedSpriteMoveEvent = extern struct {
    id1: i64,
    id2: i64,
    positionX: f64,
    positionY: f64,
    positionZ: f64,
};

pub const PackedSpriteRemoveEvent = extern struct {
    id1: i64,
    id2: i64,
};

pub const PackedSpriteResizeEvent = extern struct {
    id1: i64,
    id2: i64,
    sizeW: f64,
    sizeH: f64,
};

pub const PackedSpriteRotateEvent = extern struct {
    id1: i64,
    id2: i64,
    rotationX: f64,
    rotationY: f64,
    rotationZ: f64,
};

pub const PackedSpriteScaleEvent = extern struct {
    id1: i64,
    id2: i64,
    scaleX: f64,
    scaleY: f64,
    scaleZ: f64,
};

pub const PackedSpriteSetSourceRectEvent = extern struct {
    id1: i64,
    id2: i64,
    x: f32,
    y: f32,
    w: f32,
    h: f32,
};

pub const PackedSpriteSpeedEvent = extern struct {
    id1: i64,
    id2: i64,
    speedX: f64,
    speedY: f64,
};

pub const PackedSpriteTextureSetEvent = extern struct {
    id1: i64,
    id2: i64,
    textureId: u64,
};

pub const PackedTextAddEvent = extern struct {
    id1: i64,
    id2: i64,
    positionX: f64,
    positionY: f64,
    positionZ: f64,
    r: u8,
    g: u8,
    b: u8,
    a: u8,
    _padding1: u32,
    fontSize: f32,
    fontPathLength: u32,
    textLength: u32,
    _padding2: u32,
};

pub const PackedTextSetStringEvent = extern struct {
    id1: i64,
    id2: i64,
    textLength: u32,
    _padding: u32,
};

pub const PackedTextureLoadHeaderEvent = extern struct {
    id1: i64,
    id2: i64,
    filenameLength: u32,
    _padding: u32,
};

pub const PackedWindowFlagsEvent = extern struct {
    flags: u64,
};

pub const PackedWindowResizeEvent = extern struct {
    w: i32,
    h: i32,
};

pub const PackedWindowTitleEvent = extern struct {
    title: @Vector(256, u8),
};

pub const KVPair = struct { []const u8, u32 };
pub const event_payload_list = [_]KVPair{
    .{ "spriteAdd", @sizeOf(PackedSpriteAddEvent) },
    .{ "spriteRemove", @sizeOf(PackedSpriteRemoveEvent) },
    .{ "spriteMove", @sizeOf(PackedSpriteMoveEvent) },
    .{ "spriteScale", @sizeOf(PackedSpriteScaleEvent) },
    .{ "spriteResize", @sizeOf(PackedSpriteResizeEvent) },
    .{ "spriteRotate", @sizeOf(PackedSpriteRotateEvent) },
    .{ "spriteColor", @sizeOf(PackedSpriteColorEvent) },
    .{ "spriteSpeed", @sizeOf(PackedSpriteSpeedEvent) },
    .{ "spriteTextureLoad", @sizeOf(PackedTextureLoadHeaderEvent) },
    .{ "spriteTextureSet", @sizeOf(PackedSpriteTextureSetEvent) },
    .{ "spriteSetSourceRect", @sizeOf(PackedSpriteSetSourceRectEvent) },
    .{ "geomAddPoint", @sizeOf(PackedGeomAddPointEvent) },
    .{ "geomAddLine", @sizeOf(PackedGeomAddLineEvent) },
    .{ "geomAddRect", @sizeOf(PackedGeomAddRectEvent) },
    .{ "geomAddFillRect", @sizeOf(PackedGeomAddRectEvent) },
    .{ "geomAddPacked", @sizeOf(PackedGeomAddPackedHeaderEvent) },
    .{ "geomRemove", @sizeOf(PackedGeomRemoveEvent) },
    .{ "geomSetColor", @sizeOf(PackedGeomSetColorEvent) },
    .{ "inputKeyup", @sizeOf(PackedKeyEvent) },
    .{ "inputKeydown", @sizeOf(PackedKeyEvent) },
    .{ "inputMouseup", @sizeOf(PackedMouseButtonEvent) },
    .{ "inputMousedown", @sizeOf(PackedMouseButtonEvent) },
    .{ "inputMousemotion", @sizeOf(PackedMouseMotionEvent) },
    .{ "windowTitle", @sizeOf(PackedWindowTitleEvent) },
    .{ "windowResize", @sizeOf(PackedWindowResizeEvent) },
    .{ "windowFlags", @sizeOf(PackedWindowFlagsEvent) },
    .{ "textAdd", @sizeOf(PackedTextAddEvent) },
    .{ "textSetString", @sizeOf(PackedTextSetStringEvent) },
    .{ "audioLoad", @sizeOf(PackedAudioLoadEvent) },
    .{ "audioLoaded", @sizeOf(PackedAudioLoadedEvent) },
    .{ "audioPlay", @sizeOf(PackedAudioPlayEvent) },
    .{ "audioStopAll", @sizeOf(PackedAudioStopAllEvent) },
    .{ "audioSetMasterVolume", @sizeOf(PackedAudioSetMasterVolumeEvent) },
    .{ "audioPause", @sizeOf(PackedAudioPauseEvent) },
    .{ "audioStop", @sizeOf(PackedAudioStopEvent) },
    .{ "audioUnload", @sizeOf(PackedAudioUnloadEvent) },
    .{ "audioSetVolume", @sizeOf(PackedAudioSetVolumeEvent) },
    .{ "physicsAddBody", @sizeOf(PackedPhysicsAddBodyEvent) },
    .{ "physicsRemoveBody", @sizeOf(PackedPhysicsRemoveBodyEvent) },
    .{ "physicsApplyForce", @sizeOf(PackedPhysicsApplyForceEvent) },
    .{ "physicsApplyImpulse", @sizeOf(PackedPhysicsApplyImpulseEvent) },
    .{ "physicsSetVelocity", @sizeOf(PackedPhysicsSetVelocityEvent) },
    .{ "physicsSetPosition", @sizeOf(PackedPhysicsSetPositionEvent) },
    .{ "physicsSetRotation", @sizeOf(PackedPhysicsSetRotationEvent) },
    .{ "physicsCollisionBegin", @sizeOf(PackedPhysicsCollisionEvent) },
    .{ "physicsCollisionSeparate", @sizeOf(PackedPhysicsCollisionEvent) },
    .{ "physicsSyncTransform", @sizeOf(PackedPhysicsSyncTransformEvent) },
    .{ "physicsSetDebugMode", @sizeOf(PackedPhysicsSetDebugModeEvent) },
    .{ "plugin", @sizeOf(PackedPluginOnEvent) },
    .{ "pluginLoad", @sizeOf(PackedPluginLoadHeaderEvent) },
    .{ "pluginUnload", @sizeOf(PackedPluginUnloadEvent) },
    .{ "pluginSet", @sizeOf(PackedPluginSetEvent) },
    .{ "pluginEventStacking", @sizeOf(PackedPluginEventStackingEvent) },
    .{ "pluginSubscribeEvent", @sizeOf(PackedPluginSubscribeEvent) },
    .{ "pluginUnsubscribeEvent", @sizeOf(PackedPluginUnsubscribeEvent) },
    .{ "cameraSetPosition", @sizeOf(PackedCameraSetPositionEvent) },
    .{ "cameraMove", @sizeOf(PackedCameraMoveEvent) },
    .{ "cameraSetZoom", @sizeOf(PackedCameraSetZoomEvent) },
    .{ "cameraSetRotation", @sizeOf(PackedCameraSetRotationEvent) },
    .{ "cameraFollowEntity", @sizeOf(PackedCameraFollowEntityEvent) },
    .{ "cameraStopFollowing", @sizeOf(PackedCameraStopFollowingEvent) },
    .{ "scriptSubscribe", @sizeOf(PackedScriptSubscribeEvent) },
    .{ "scriptUnsubscribe", @sizeOf(PackedScriptUnsubscribeEvent) },
};
pub const event_payload_sizes = std.StaticStringMap(u32).initComptime(event_payload_list);

pub const Keycode = struct {
    pub const A: u32 = 97;
    pub const D: u32 = 100;
};

pub const CommandPacker = struct {
    writer: std.ArrayList(u8).Writer,
    command_count: u32 = 0,

    // Pad to 8-byte boundary
    fn padToBoundary(self: *CommandPacker) !void {
        // Note: writer.context is the ArrayList
        const current_len = self.writer.context.items.len;
        const padding = (8 - (current_len % 8)) % 8;
        if (padding > 0) {
            try self.writer.writeByteNTimes(0, padding);
        }
    }

    fn writePaddedString(self: *CommandPacker, str: []const u8) !void {
        try self.writer.writeAll(str);
        const padding = (8 - (str.len % 8)) % 8;
        if (padding > 0) {
            try self.writer.writeByteNTimes(0, padding);
        }
    }

    pub fn pack(self: *CommandPacker, event_type: Events, payload: anytype) !void {
        // Header: Type(4) + Timestamp(8) + Pad(4) = 16 bytes
        try self.writer.writeInt(u32, @intFromEnum(event_type), .little);
        try self.writer.writeInt(u64, 0, .little); // timestamp
        try self.writer.writeInt(u32, 0, .little); // padding

        try self.writer.writeAll(std.mem.asBytes(&payload));
        try self.padToBoundary();
        self.command_count += 1;
    }

    // Specialized helper for commands with strings
    // Note: This assumes the header struct (PackedTextureLoadHeaderEvent, etc.)
    // aligns correctly to 8 bytes before the string starts, or handles its own padding.
    // Given the new structs, most do.

    pub fn packTextureLoad(self: *CommandPacker, id1: i64, id2: i64, path: []const u8) !void {
        try self.writer.writeInt(u32, @intFromEnum(Events.spriteTextureLoad), .little);
        try self.writer.writeInt(u64, 0, .little);
        try self.writer.writeInt(u32, 0, .little); // header padding

        const header = PackedTextureLoadHeaderEvent{
            .id1 = id1,
            .id2 = id2,
            .filenameLength = @intCast(path.len),
            ._padding = 0,
        };
        try self.writer.writeAll(std.mem.asBytes(&header));
        try self.writePaddedString(path);

        try self.padToBoundary();
        self.command_count += 1;
    }

    // Add other specialized packers similarly (TextAdd, etc.) ensuring padToBoundary is called.
};

pub const EventUnpacker = struct {
    stream: std.io.FixedBufferStream([]const u8),

    pub fn init(blob: []const u8) EventUnpacker {
        return .{
            .stream = std.io.fixedBufferStream(blob),
        };
    }

    pub fn read(self: *EventUnpacker, comptime T: type) !T {
        return self.stream.reader().readInt(T, .little);
    }

    pub fn readPayload(self: *EventUnpacker, comptime T: type) !T {
        const bytes_array = try self.stream.reader().readBytesNoEof(@sizeOf(T));
        return std.mem.bytesAsValue(T, &bytes_array).*;
    }

    // Skips bytes until the current position is a multiple of `alignment`
    pub fn alignTo(self: *EventUnpacker, alignment: usize) !void {
        const current_pos = self.stream.getPos() catch return;
        const padding = (alignment - (current_pos % alignment)) % alignment;
        if (padding > 0) {
            try self.stream.reader().skipBytes(@intCast(padding), .{});
        }
    }

    // Reads a string of length `len` and then skips the padding
    pub fn skipStringAligned(self: *EventUnpacker, len: u32) !void {
        try self.stream.reader().skipBytes(len, .{});
        const padding = (8 - (len % 8)) % 8;
        if (padding > 0) {
            try self.stream.reader().skipBytes(padding, .{});
        }
    }

    pub fn skip(self: *EventUnpacker, N: u32) !void {
        try self.stream.reader().skipBytes(@intCast(N), .{});
    }
};

pub fn hexdump_util(writer: anytype, slice: []const u8) anyerror!void {
    const ROW_SIZE = 16;
    var i: usize = 0;

    while (i < slice.len) : (i += ROW_SIZE) {
        const row_end = @min(i + ROW_SIZE, slice.len);
        const row = slice[i..row_end];

        try writer.print("{x:0>8} ", .{@as(u32, @intCast(i))});

        var j: usize = 0;
        while (j < ROW_SIZE) : (j += 1) {
            if (j < row.len) {
                try writer.print("{x:0>2} ", .{row[j]});
            } else {
                try writer.writeAll("   ");
            }
        }

        try writer.writeAll(" |");
        for (row) |byte| {
            if (byte >= 0x20 and byte <= 0x7E) {
                try writer.writeByte(byte);
            } else {
                try writer.writeByte('.');
            }
        }
        try writer.writeAll("|\n");
    }
}

pub const ChannelPacker = struct {
    pub const ChannelInput = struct {
        id: u32,
        data: []const u8,
    };

    pub fn finalize(writer: anytype, channels: []const ChannelInput) !void {
        // Write Channel Count (u32)
        try writer.writeInt(u32, @intCast(channels.len), .little);
        // Write Padding (u32) - REQUIRED to match Swift/PHP "Vx4"
        try writer.writeInt(u32, 0, .little);

        for (channels) |channel| {
            try writer.writeInt(u32, channel.id, .little);
            try writer.writeInt(u32, @intCast(channel.data.len), .little);
        }
        for (channels) |channel| {
            try writer.writeAll(channel.data);
        }
    }
};

pub const ChannelUnpacker = struct {
    pub const ChannelInfo = struct {
        offset: u32,
        size: u32,
    };
    blob: []const u8,
    index_table: std.AutoHashMap(u32, ChannelInfo),

    const Header = extern struct {
        channel_id: u32,
        channel_size: u32,
    };

    pub fn init(blob: []const u8, allocator: std.mem.Allocator) !ChannelUnpacker {
        var self = ChannelUnpacker{
            .blob = blob,
            .index_table = std.AutoHashMap(u32, ChannelInfo).init(allocator),
        };
        var stream = std.io.fixedBufferStream(blob);
        const reader = stream.reader();

        const channel_count = reader.readInt(u32, .little) catch return error.InvalidFormat;

        // Skip 4 bytes padding to align after channel count?
        // Note: ChannelPacker.php doesn't seem to pad the channel count *itself* in finalize(),
        // but CommandPacker DOES.
        // However, `finalize` in PHP: `pack("Vx4", $channelCount)`
        // YES, PHP `ChannelPacker::finalize` pads the count!
        try reader.skipBytes(4, .{}); // Skip padding

        const index_table_size: u32 = channel_count * @sizeOf(Header);
        // 8 bytes (count + pad) + table size
        const data_start_offset: u32 = 8 + index_table_size;

        if (data_start_offset > blob.len) return error.InvalidFormat;

        var current_data_offset = data_start_offset;

        for (0..channel_count) |_| {
            const id = reader.readInt(u32, .little) catch return error.InvalidFormat;
            const size = reader.readInt(u32, .little) catch return error.InvalidFormat;

            if (current_data_offset + size > blob.len) return error.InvalidFormat;

            try self.index_table.put(id, .{
                .offset = current_data_offset,
                .size = size,
            });
            current_data_offset += size;
        }

        return self;
    }

    pub fn deinit(self: *ChannelUnpacker) void {
        self.index_table.deinit();
    }

    pub fn getChannelEventUnpacker(self: *ChannelUnpacker, channel_id: Channels) ?EventUnpacker {
        const id_raw = @intFromEnum(channel_id);
        const info = self.index_table.get(id_raw) orelse return null;

        const channel_blob = self.blob[info.offset .. info.offset + info.size];
        return EventUnpacker.init(channel_blob);
    }
};
